152c152
< $( // Taken from com/bcplcgz80.b to help show all the Z80 istructions
---
> $( // Taken from bcplchz80.b to help show all the Z80 istructions
265,266d264
< notyet        // (pc) the instruction at pc is not yet implemented
<               // It returns the size of the offending instruction.
268d265
< cc2str
274c271
< r_i;  r_r   // Interrupt page register and the memory refresh register
---
> r_i;  r_d   // Interrupt page register and the memory refresh register
277,281c274,279
< r_fval;  r_fval1   // Used to detemine S and Z
< r_fpval; r_fpval1  // Used to detemine P/V
< r_fhval; r_fhval1  // Used to detemine H
< r_fn;    r_fn1
< r_fc;    r_fc1
---
> r_fs; r_fs1
> r_fz; r_fz1
> r_fh; r_fh1
> r_fv; r_fv1
> r_fn; r_fn1
> r_fc; r_fc1
292d289
< getswb
294d290
< getsww
317d312
< tracing
324,326c319
< 
< trcount    // Set by the TR command to trace the exeution of a number
<            // of instructions. When not tracing its value is -1
---
> oldcount
359,362c352,355
< doz80instrCB   // (a)   Print or execute one instruction with op BC
< doz80instrED   // (a)   Print or execute one instruction with op EB
< doz80instrXD   // (a)   Print or execute one instruction with op DD or FD
< doz80instrXDCB // (a)   Print or execute one instruction with op XD CB
---
> doz80instrCB  // (a)   Print or execute one instruction with op BC
> doz80instrED  // (a)   Print or execute one instruction with op EB
> doz80instrXD  // (a)   Print or execute one instruction with op DD or FD
> doz80RST38    // {a}   Print or execute the instruction RST #x38
369c362
< //    r    r_a, r_b etc
---
> //    r    r_a,
426,429d418
< z80JPccnn
< z80JPccd
< z80JPd
< z80JPir
456c445
< z80RRCr
---
> z80RCCr
555,556d543
<   n_i       // I
<   n_r       // R
560,568c547,557
<   // Condition codes
<   cc_c=1     // C       These are needed by eg RET M  or RET NZ
<   cc_m       // M
<   cc_nc      // NC
<   cc_nz      // NZ
<   cc_p       // P
<   cc_pe      // PE
<   cc_po      // PO
<   cc_z       // Z
---
>   n_m       // M       These are needed by eg RET M  or RET NZ
>   n_nz      // NZ
>   n_nc      // NC
>   n_p       // P
>   n_pe      // PE
>   n_po      // PO
>   n_z       // Z
>   n_i       // I
>   n_r       // R
> 
>   // F register bit patterns
569a559,574
>   fb_c = #b00000001  // carry
>   fb_n = #b00000001  // add/subtract
>   fb_v = #b00000100  // parity/overflow
>   fb_p = #b00000100  // parity/overflow
>   fb_h = #b00010000  // half carry
>   fb_z = #b01000000  // zero
>   fb_s = #b10000000  // sign
>   
>   fb_nc = #b00000001 XOR #xFF // not carry
>   fb_nn = #b00000001 XOR #xFF // not add/subtract
>   fb_nv = #b00000100 XOR #xFF // not parity/overflow
>   fb_np = #b00000100 XOR #xFF // not parity/overflow
>   fb_nh = #b00010000 XOR #xFF // not half carry
>   fb_nz = #b01000000 XOR #xFF // not zero
>   fb_ns = #b10000000 XOR #xFF // not sign
>   
618,619c623
<   tracing := singlestep
<   
---
> 
631c635
<   //singlestep, tracing := FALSE, FALSE
---
>   //singlestep := FALSE
638c642
<   r_i,  r_r := 0, 0  // Interrupt page register and the memory refresh register
---
>   r_i,  r_d := 0, 0    // Interrupt page register and the memory refresh register
641,642c645,646
<   r_fval,  r_fpval,  r_fhval,  r_fn,  r_fc  := 0, 0, 0, 0, 0
<   r_fval1, r_fpval1, r_fhval1, r_fn1, r_fc1 := 0, 0, 0, 0, 0
---
>   r_fs,  r_fz,  r_fh,  r_fv,  r_fn,  r_fc  := 0, 0, 0, 0, 0, 0
>   r_fs1, r_fz1, r_fh1, r_fv1, r_fn1, r_fc1 := 0, 0, 0, 0, 0, 0
707c711
<   //singlestep, tracing := TRUE, TRUE  // Normally set by the -s option
---
>   //singlestep := TRUE  // Normally set by the -s option
725,726c729,730
<     { IF trcount=0 DO { faultcode := 18; BREAK }
<       IF count=0   DO { faultcode := 1;  BREAK }
---
>     { //singlestep := TRUE
>       //db("calling doz80instr()")
729,732c733,734
<       IF tracing DO prstate()
<       IF count  >0 DO count   := count-1
<       IF trcount>0 DO trcount := trcount-1
<     } REPEATUNTIL faultcode | singlestep
---
>       //db("returned from doz80instr()")
>     } REPEATUNTIL faultcode | singlestep | brkstep
741,743c743,746
< { // This returns 1 if the 8-bit pattern w has even parity.
<   LET t = TABLE 1,0,0,1, 0,1,1,0, 0,1,1,0,1,0,0,1
<   // If bbbb is an even parity 4-bit pattern then t!bbbb returns 1
---
> { //This returns fb_v if te 8-bit pattern w has even parity
>   MANIFEST { e=fb_v }
>   LET t = TABLE e,0,0,e, 0,e,e,0, 0,e,e,0,e,0,0,e
>   // If bbbb is an even parity 4-bit pattern then t!bbbb returns fb_v
771c774
< // of the global variables faultcode trcount brkstep and singlestep.
---
> // of the global variables faultcode brkstep and singlesep.
823d825
<       prstate()
830,855c832,862
<     { DEFAULT:  RESULTIS "Unknown fault"
<     
<       CASE   1: RESULTIS "Illegal instruction"
<       CASE   2: RESULTIS "BRK instruction"
<       CASE   3: RESULTIS "Zero count"
<       CASE   4: RESULTIS "pc out of range"
<       CASE   5: RESULTIS "Division by zero"
<       CASE  11: RESULTIS "Watch addr: %+%i7 value: %i8"
<       CASE  12: RESULTIS "Indirect address out of range: %+%+%+%n"
<       CASE  13: RESULTIS "SIGINT received"
<       CASE  15: RESULTIS "PC out of range"
<       CASE  16: RESULTIS "P pointer out of range"
<       CASE  17: RESULTIS "SIGSEGV occurred"
<       CASE  18: RESULTIS "Zero trcount"
<       CASE  99: RESULTIS "User requested"
<       CASE 110: RESULTIS "Callco fault"
<       CASE 111: RESULTIS "Resumeco fault"
<       CASE 112: RESULTIS "Deleteco fault"
<       CASE 186: RESULTIS "Bad input stream"
<       CASE 187: RESULTIS "Bad output stream"
<       CASE 188: RESULTIS "Unable to replenish input"
<       CASE 189: RESULTIS "Wrch fault"
<       CASE 190: RESULTIS "Endread fault"
<       CASE 191: RESULTIS "Endwrite fault"
<       CASE 197: RESULTIS "Store chain fault"
<     }
---
>                 { CASE  -3: RESULTIS "Break from rasterp"
> 		  CASE   1: RESULTIS "Illegal instruction"
>                   CASE   2: RESULTIS "BRK instruction"
>                   CASE   3: RESULTIS "Zero count"
>                   CASE   4: RESULTIS "pc out of range"
>                   CASE   5: RESULTIS "Division by zero"
>                   CASE  10: RESULTIS "Cintasm single step"
>                   CASE  11: RESULTIS "Watch addr: %+%i7 value: %i8"
>                   CASE  12: RESULTIS "Indirect address out of range: %+%+%+%n"
>                   CASE  13: RESULTIS "SIGINT received"
>                   CASE  14: RESULTIS "Unknown FLT op %+%n"
>                   CASE  15: RESULTIS "PC out of range"
>                   CASE  16: RESULTIS "P pointer out of range"
>                   CASE  17: RESULTIS "SIGSEGV occurred"
>                   CASE  18: RESULTIS "End of instruction tracing"
>                   CASE  99: RESULTIS "User requested"
>                   CASE 110: RESULTIS "Callco fault"
>                   CASE 111: RESULTIS "Resumeco fault"
>                   CASE 112: RESULTIS "Deleteco fault"
>                   CASE 180: RESULTIS "Unable to delete a task"
>                   CASE 181: RESULTIS "Unable to send a packet"
>                   CASE 182: RESULTIS "Unexpected pkt received"
>                   CASE 186: RESULTIS "Bad input stream"
>                   CASE 187: RESULTIS "Bad output stream"
>                   CASE 188: RESULTIS "Unable to replenish input"
>                   CASE 189: RESULTIS "Wrch fault"
>                   CASE 190: RESULTIS "Endread fault"
>                   CASE 191: RESULTIS "Endwrite fault"
>                   CASE 197: RESULTIS "Store chain fault"
>                   DEFAULT:  RESULTIS "Unknown fault"
>                 }
858,866c865
<            brkstep := TRUE // This causes the next instruction to be
< 	                   // executed with all breakpoints removed
< 			   // and with singlestep set to TRUE.
< 			   // If brkstep is TRUE and singlestep is FALSE
< 			   // after an instruction has been executed
< 			   // normsl execution of instructions resumes
< 			   // with all current breakpoint set.
< 			   // brkstep is always set to FALSE except when
< 			   // resuming execution after a breakpoint.
---
>            brkstep := TRUE
875c874
<   IF singlestep & tracing DO prstate()
---
>   prstate()
952c951
<     CASE 'A': CASE 'G': CASE 'P': CASE 'R':
---
>     CASE 'G': CASE 'P': CASE 'R':
1046d1044
<       tracing := TRUE
1062c1060
<     CASE 'T': // TS  TF  TRn  TBn  Tn
---
>     CASE 'T': // TRn  TBn  TS  TF  Tn
1063a1062
>       //writef(" CASE 'T': ch=%i3='%c'*n", ch, ch)
1082,1087c1081,1083
<         { trcount := rdn()
<           tracing := TRUE
< 	  singlestep := FALSE
< 	  GOTO ret         // Resume execution while
< 	                   // trcount>0 or faultcode~=0
< 			   // tracing each instruction.
---
>         { LET n = rdn()
>  	  sys(Sys_settracing, n+1)
> 	  GOTO ret
1135c1131
<       { LET n = ch - '0'  // Set or Clear break point n.
---
>       { LET n = ch - '0'  // Set or Clear a break point.
1139d1134
< 	// Clear any breakpoint for this address
1141,1142c1136
< 	// Set breakpoint n for this address
<         bpt_addr!n, bpt_instr!n := val, mem%val
---
>         bpt_addr!n, bpt_instr!n := val, 0%val
1145d1138
<       // B is not followed by a digit so list the breakpoints.
1147c1140
<       FOR i = 0 TO 9 DO
---
>       FOR i = 0 TO 9 DO  // List all breakpoints.
1149c1142
<         IF ba DO
---
>         UNLESS ba=0 DO
1168c1161
<       { brkstep := TRUE       // Resuming from a breakpoint
---
>       { brkstep := TRUE
1170,1171c1163
< 	RETURN                // Obey one instruction before restoring
< 	                      // the breakpoints.
---
> 	RETURN
1175d1166
<       tracing := FALSE
1194c1185,1188
<   UNLESS brkstep DO setbreakpoints()
---
>   UNLESS brkstep FOR i = 0 TO 9 DO
>   { LET ba=bpt_addr!i         // If brkstep=FALSE insert BRK at every breakpoint.
>     IF ba DO putbb(ba, f_brk)
>   }
1201,1202c1195,1196
<   { bpt_instr!i := getbb(ba) // Save the previous instruction at the
<     putbb(ba, f_brk)         // breakpoint. and replace it by BRK (=RST #x28)
---
>   { bpt_instr!i := getbb(ba) // Save the previous instruction at the breakpoint.
>     putbb(ba, f_brk)         // Replace it by BRK (=RST #x28)
1208c1202
<   IF ba DO putbb(ba, bpt_instr!i) // Restore the original instruction.
---
>   IF ba DO putbb(ba, bpt_instr!i)
1356c1350
<     CASE 'A':  rch()        // A n   Return the contents of word address n
---
>     CASE 'A':  rch()
1479c1473
<     FOR i = 2 TO 5 DO { wrch(' '); prW(getww(pptr+i)) }
---
>     FOR i = 2 TO 6 DO { wrch(' '); prW(getww(pptr+i)) }
1481d1474
<     writef("  "); prflags()
1501c1494,1498
< AND getsbb(a) = signextb(mem%a)
---
> AND getsbb(a) = VALOF
> { LET byte = mem%a
>   IF  byte<=127 RESULTIS byte
>   RESULTIS byte-256
> }
1505,1506d1501
< AND getswb(a) = signextw(mem%a | mem%(a+1)<<8)
< 
1509,1510d1503
< AND getsww(a) = signextw(getwb(a+a))
< 
1729,1745c1722,2568
<   IF r_fval<0        DO wrch('S')
<   IF r_fval=0        DO wrch('Z')
<   IF r_fhval         DO wrch('H')
<   IF parity(r_fpval) DO wrch('V')
<   IF r_fn            DO wrch('N')
<   IF r_fc            DO wrch('C')
< }
< 
< AND setr_f() BE
< { // Use r_fval, r_fpval, r_fh, r_fn, r_fc to set r_f
<   r_f := 0                      //  SZ_H _PNC   Flagregister bit positions
<   IF r_fval<0        DO r_f :=     #b1000_0000   // S
<   IF r_fval=0        DO r_f :=     #b0100_0000   // Z
<   IF r_fhval         DO r_f := r_f+#b0001_0000   // H
<   IF parity(r_fpval) DO r_f := r_f+#b0000_0100   // P/V
<   IF r_fn            DO r_f := r_f+#b0000_0010   // N
<   IF r_fc            DO r_f := r_f+#b0000_0001   // C
---
>   IF r_fs DO wrch('S')
>   IF r_fz DO wrch('Z')
>   IF r_fh DO wrch('H')
>   IF r_fv DO wrch('V')
>   IF r_fn DO wrch('N')
>   IF r_fc DO wrch('C')
> }
> 
> AND prz80instr(pc) = VALOF
> { // Print the Z80 instruction at location pc
>   // and return its size in bytes.
>   pflag := TRUE
>   RESULTIS doz80instr(pc)
> }
> 
> AND doz80instr(pc) = VALOF
> { // If pflag=TRUE output the instruction at location pc and
>   //               return its size in bytes.
>   // If pflag=FALSE execute the instruction at location pc (=r_pc) and
>   // return zero if the instruction does not cause a fault or
>   // return a non zero fault code.
>   
>   LET op = getbb(pc)
> 
> UNLESS pflag DO
> { //db("*nEntered doz80instr() pc=%n op=%x2", pc, op)
> }
>   SWITCHON op INTO
>   { CASE #x00: RESULTIS z80NOP()                   // NOP
>     CASE #x01: RESULTIS z80LD16rnn(pc, n_bc)       // LD BC,nn
>     CASE #x02: RESULTIS z80LDrr(pc, n_ibc, n_a)    // LD (BC),A
>     CASE #x03: RESULTIS z80INC16r(pc, n_bc)        // INC BC
>     CASE #x04: RESULTIS z80INCr(pc, n_b)           // INC B
>     CASE #x05: RESULTIS z80DECr(pc, n_b)           // DEC B
>     CASE #x06: RESULTIS z80LDrn(pc, n_b)           // LD B,n
>     CASE #x07: RESULTIS prbadop(pc)
>     CASE #x08: RESULTIS z80EXrr(pc, n_af, n_af1)   // EX AF,AF'
>     CASE #x09: RESULTIS z80ADD16rr(pc, n_hl, n_bc) // ADD HL,BC
>     CASE #x0A: RESULTIS z80LDrr(pc, n_a, n_ibc)    // LD A,(BC)
>     CASE #x0B: RESULTIS z80DEC16r(pc, n_bc)        // DEC BC
>     CASE #x0C: RESULTIS z80INCr(pc, n_c)           // INC C
>     CASE #x0D: RESULTIS z80DECr(pc, n_c)           // DEC C
>     CASE #x0E: RESULTIS z80LDrn(pc, n_c)           // LD C,n
>     CASE #x0F: RESULTIS z80RRCA(pc)                // RRCA
> 
>     CASE #x10: RESULTIS prbadop(pc)
>     CASE #x11: RESULTIS z80LD16rnn(pc, n_de)       // LD DE,nn
>     CASE #x12: RESULTIS z80LDrr(pc, n_ide, n_a)    // LD (DE),A
>     CASE #x13: RESULTIS z80INC16r(pc, n_de)        // INC DE
>     CASE #x14: RESULTIS z80INCr(pc, n_d)           // INC D
>     CASE #x15: RESULTIS z80DECr(pc, n_d)           // DEC D
>     CASE #x16: RESULTIS z80LDrn(pc, n_d)           // LD D,n
>     CASE #x17: RESULTIS prbadop(pc)
>     CASE #x18: RESULTIS prbadop(pc)
>     CASE #x19: RESULTIS z80ADD16rr(pc, n_hl, n_de) // ADD HL,DE
>     CASE #x1A: RESULTIS z80LDrr(pc, n_a, n_ide)    // LD A,(DE)
>     CASE #x1B: RESULTIS z80DEC16r(pc, n_de)        // DEC DE
>     CASE #x1C: RESULTIS z80INCr(pc, n_e)           // INC E
>     CASE #x1D: RESULTIS z80DECr(pc, n_e)           // DEC E
>     CASE #x1E: RESULTIS z80LDrn(pc, n_e)           // LD E,n
>     CASE #x1F: RESULTIS prbadop(pc)
> 
>     CASE #x20: RESULTIS z80JRra(pc, n_nz)          // JR NZ,rel
>     CASE #x21: RESULTIS z80LD16rnn(pc, n_hl)       // LD r,nn
>     CASE #x22: RESULTIS prbadop(pc)
>     CASE #x23: RESULTIS z80INC16r(pc, n_hl)        // INC HL
>     CASE #x24: RESULTIS z80INCr(pc, n_h)           // INC H
>     CASE #x25: RESULTIS z80DECr(pc, n_h)           // DEC H
>     CASE #x26: RESULTIS z80LDrn(pc, n_h)           // LD H,n
>     CASE #x27: RESULTIS z80DAAr(pc)                // DAA
>     CASE #x28: RESULTIS prbadop(pc)
>     CASE #x29: RESULTIS z80ADD16rr(pc, n_hl, n_hl) // ADD HL,HL
>     CASE #x2A: RESULTIS prbadop(pc)
>     CASE #x2B: RESULTIS z80DEC16r(pc, n_hl)        // DEC HL
>     CASE #x2C: RESULTIS z80INCr(pc, n_l)           // INC L
>     CASE #x2D: RESULTIS z80DECr(pc, n_l)           // DEC L
>     CASE #x2E: RESULTIS z80LDrn(pc, n_l)           // LD L,n
>     CASE #x2F: RESULTIS z80CPL(pc)                 // CPL
> 
>     CASE #x30: RESULTIS prbadop(pc)
>     CASE #x31: RESULTIS prbadop(pc)
>     CASE #x32: RESULTIS z80LDinnr(pc, n_a)         // LD (nn),A
>     CASE #x33: RESULTIS z80INC16r(pc, n_sp)        // INC SP
>     CASE #x34: RESULTIS z80INCr(pc, n_ihl)         // INC (HL)
>     CASE #x35: RESULTIS z80DECr(pc, n_ihl)         // DEC (HL)
>     CASE #x36: RESULTIS z80LDrn(pc, n_ihl)         // LD (HL),n
>     CASE #x37: RESULTIS z80SCF(pc)                 // SCF
>     CASE #x38: RESULTIS prbadop(pc)
>     CASE #x39: RESULTIS z80ADD16rr(pc, n_hl, n_sp) // ADD HL,SP
>     CASE #x3A: RESULTIS z80LDrinn(pc, n_a)         // LD A,(nn)
>     CASE #x3B: RESULTIS z80DEC16r(pc, n_sp)        // DEC SP
>     CASE #x3C: RESULTIS z80INCr(pc, n_a)           // INC A
>     CASE #x3D: RESULTIS z80DECr(pc, n_a)           // DEC A
>     CASE #x3E: RESULTIS z80LDrn(pc, n_a)           // LD A,n
>     CASE #x3F: RESULTIS z80CCF(pc)                 // CCF
> 
>     CASE #x40: RESULTIS z80LDrr(pc, n_b, n_b)      // LD B,B
>     CASE #x41: RESULTIS z80LDrr(pc, n_b, n_c)      // LD B,C
>     CASE #x42: RESULTIS z80LDrr(pc, n_b, n_d)      // LD B,D
>     CASE #x43: RESULTIS z80LDrr(pc, n_b, n_e)      // LD B,E
>     CASE #x44: RESULTIS z80LDrr(pc, n_b, n_h)      // LD B,H
>     CASE #x45: RESULTIS z80LDrr(pc, n_b, n_l)      // LD B,L
>     CASE #x46: RESULTIS z80LDrr(pc, n_b, n_ihl)    // LD B,(HL)
>     CASE #x47: RESULTIS z80LDrr(pc, n_b, n_a)      // LD B,A
>     CASE #x48: RESULTIS z80LDrr(pc, n_c, n_b)      // LD C,B
>     CASE #x49: RESULTIS z80LDrr(pc, n_c, n_c)      // LD C,C
>     CASE #x4A: RESULTIS z80LDrr(pc, n_c, n_d)      // LD C,D
>     CASE #x4B: RESULTIS z80LDrr(pc, n_c, n_e)      // LD C,E
>     CASE #x4C: RESULTIS z80LDrr(pc, n_c, n_h)      // LD C,H
>     CASE #x4D: RESULTIS z80LDrr(pc, n_c, n_l)      // LD C,L
>     CASE #x4E: RESULTIS z80LDrr(pc, n_c, n_ihl)    // LD C,(HL)
>     CASE #x4F: RESULTIS z80LDrr(pc, n_c, n_a)      // LD C,A
> 
>     CASE #x50: RESULTIS z80LDrr(pc, n_d, n_b)      // LD D,B
>     CASE #x51: RESULTIS z80LDrr(pc, n_d, n_c)      // LD D,C
>     CASE #x52: RESULTIS z80LDrr(pc, n_d, n_d)      // LD D,D
>     CASE #x53: RESULTIS z80LDrr(pc, n_d, n_e)      // LD D,E
>     CASE #x54: RESULTIS z80LDrr(pc, n_d, n_h)      // LD D,H
>     CASE #x55: RESULTIS z80LDrr(pc, n_d, n_l)      // LD D,L
>     CASE #x56: RESULTIS z80LDrr(pc, n_d, n_ihl)    // LD D,(HL)
>     CASE #x57: RESULTIS z80LDrr(pc, n_d, n_a)      // LD D,A
>     CASE #x58: RESULTIS z80LDrr(pc, n_e, n_b)      // LD E,B
>     CASE #x59: RESULTIS z80LDrr(pc, n_e, n_c)      // LD E,C
>     CASE #x5A: RESULTIS z80LDrr(pc, n_e, n_d)      // LD E,D
>     CASE #x5B: RESULTIS z80LDrr(pc, n_e, n_e)      // LD E,E
>     CASE #x5C: RESULTIS z80LDrr(pc, n_e, n_d)      // LD E,H
>     CASE #x5D: RESULTIS z80LDrr(pc, n_e, n_l)      // LD E,L
>     CASE #x5E: RESULTIS z80LDrr(pc, n_e, n_ihl)    // LD E,(HL)
>     CASE #x5F: RESULTIS z80LDrr(pc, n_e, n_a)      // LD E,A
> 
>     CASE #x60: RESULTIS z80LDrr(pc, n_h, n_b)      // LD H,B
>     CASE #x61: RESULTIS z80LDrr(pc, n_h, n_c)      // LD H,C
>     CASE #x62: RESULTIS z80LDrr(pc, n_h, n_d)      // LD H,D
>     CASE #x63: RESULTIS z80LDrr(pc, n_h, n_e)      // LD H,E
>     CASE #x64: RESULTIS z80LDrr(pc, n_h, n_h)      // LD H,H
>     CASE #x65: RESULTIS z80LDrr(pc, n_h, n_l)      // LD H,L
>     CASE #x66: RESULTIS z80LDrr(pc, n_h, n_ihl)    // LD H,(HL)
>     CASE #x67: RESULTIS z80LDrr(pc, n_h, n_a)      // LD H,A
>     CASE #x68: RESULTIS z80LDrr(pc, n_l, n_b)      // LD L,B
>     CASE #x69: RESULTIS z80LDrr(pc, n_l, n_c)      // LD L,C
>     CASE #x6A: RESULTIS z80LDrr(pc, n_l, n_d)      // LD L,D
>     CASE #x6B: RESULTIS z80LDrr(pc, n_l, n_e)      // LD L,E
>     CASE #x6C: RESULTIS z80LDrr(pc, n_l, n_h)      // LD L,H
>     CASE #x6D: RESULTIS z80LDrr(pc, n_l, n_l)      // LD L,L
>     CASE #x6E: RESULTIS z80LDrr(pc, n_l, n_ihl)    // LD L,(HL)
>     CASE #x6F: RESULTIS z80LDrr(pc, n_l, n_a)      // LD L,A
> 
>     CASE #x70: RESULTIS z80LDrr(pc, n_hl, n_b)     // LD (HL),B
>     CASE #x71: RESULTIS z80LDrr(pc, n_hl, n_c)     // LD (HL),C
>     CASE #x72: RESULTIS z80LDrr(pc, n_hl, n_d)     // LD (HL),D
>     CASE #x73: RESULTIS z80LDrr(pc, n_hl, n_e)     // LD (HL),E
>     CASE #x74: RESULTIS z80LDrr(pc, n_hl, n_h)     // LD (HL),H
>     CASE #x75: RESULTIS z80LDrr(pc, n_hl, n_l)     // LD (HL),L
>     CASE #x76: RESULTIS z80HALT(pc)                // HALT
>     CASE #x77: RESULTIS z80LDrr(pc, n_ihl, n_a)    // LD (HL),A
>     CASE #x78: RESULTIS z80LDrr(pc, n_a, n_b)      // LD A,B
>     CASE #x79: RESULTIS z80LDrr(pc, n_a, n_c)      // LD A,C
>     CASE #x7A: RESULTIS z80LDrr(pc, n_a, n_d)      // LD A,D
>     CASE #x7B: RESULTIS z80LDrr(pc, n_a, n_e)      // LD A,E
>     CASE #x7C: RESULTIS z80LDrr(pc, n_a, n_h)      // LD A,H
>     CASE #x7D: RESULTIS z80LDrr(pc, n_a, n_l)      // LD A,L
>     CASE #x7E: RESULTIS z80LDrr(pc, n_a, n_ihl)    // LD A,(HL)
>     CASE #x7F: RESULTIS z80LDrr(pc, n_a, n_a)      // LD A,A
> 
>     CASE #x80: RESULTIS z80ADDr(pc, n_b)           // ADD B
>     CASE #x81: RESULTIS z80ADDr(pc, n_c)           // ADD C
>     CASE #x82: RESULTIS z80ADDr(pc, n_d)           // ADD D
>     CASE #x83: RESULTIS z80ADDr(pc, n_e)           // ADD E
>     CASE #x84: RESULTIS z80ADDr(pc, n_h)           // ADD H
>     CASE #x85: RESULTIS z80ADDr(pc, n_l)           // ADD L
>     CASE #x86: RESULTIS z80ADDr(pc, n_ihl)         // ADD (HL)
>     CASE #x87: RESULTIS z80ADDr(pc, n_a)           // ADD A
>     CASE #x88: RESULTIS z80ADCr(pc, n_b)           // ADC B
>     CASE #x89: RESULTIS z80ADCr(pc, n_c)           // ADC C
>     CASE #x8A: RESULTIS z80ADCr(pc, n_d)           // ADC D
>     CASE #x8B: RESULTIS z80ADCr(pc, n_e)           // ADC E
>     CASE #x8C: RESULTIS z80ADCr(pc, n_h)           // ADC H
>     CASE #x8D: RESULTIS z80ADCr(pc, n_l)           // ADC L
>     CASE #x8E: RESULTIS z80ADCr(pc, n_ihl)         // ADC (HL)
>     CASE #x8F: RESULTIS z80ADCr(pc, n_a)           // ADC A
> 
>     CASE #x90: RESULTIS z80SUBr(pc, n_b)           // SUB B
>     CASE #x91: RESULTIS z80SUBr(pc, n_c)           // SUB C
>     CASE #x92: RESULTIS z80SUBr(pc, n_d)           // SUB D
>     CASE #x93: RESULTIS z80SUBr(pc, n_e)           // SUB E
>     CASE #x94: RESULTIS z80SUBr(pc, n_h)           // SUB H
>     CASE #x95: RESULTIS z80SUBr(pc, n_l)           // SUB L
>     CASE #x96: RESULTIS z80SUBr(pc, n_ihl)         // SUB (HL)
>     CASE #x97: RESULTIS z80SUBr(pc, n_a)           // SUB A
>     CASE #x98: RESULTIS z80SBCr(pc, n_b)           // SBC B
>     CASE #x99: RESULTIS z80SBCr(pc, n_c)           // SBC C
>     CASE #x9A: RESULTIS z80SBCr(pc, n_d)           // SBC D
>     CASE #x9B: RESULTIS z80SBCr(pc, n_e)           // SBC E
>     CASE #x9C: RESULTIS z80SBCr(pc, n_h)           // SBC H
>     CASE #x9D: RESULTIS z80SBCr(pc, n_l)           // SBC L
>     CASE #x9E: RESULTIS z80SBCr(pc, n_ihl)         // SBC (HL)
>     CASE #x9F: RESULTIS z80SBCr(pc, n_a)           // SBC A
> 
>     CASE #xA0: RESULTIS z80ANDr(pc, n_b)           // AND B
>     CASE #xA1: RESULTIS z80ANDr(pc, n_c)           // AND C
>     CASE #xA2: RESULTIS z80ANDr(pc, n_d)           // AND D
>     CASE #xA3: RESULTIS z80ANDr(pc, n_e)           // AND E
>     CASE #xA4: RESULTIS z80ANDr(pc, n_h)           // AND H
>     CASE #xA5: RESULTIS z80ANDr(pc, n_l)           // AND L
>     CASE #xA6: RESULTIS z80ANDr(pc, n_ihl)         // AND (HL)
>     CASE #xA7: RESULTIS z80ANDr(pc, n_a)           // AND A
>     CASE #xA8: RESULTIS z80XORr(pc, n_b)           // XOR B
>     CASE #xA9: RESULTIS z80XORr(pc, n_c)           // XOR C
>     CASE #xAA: RESULTIS z80XORr(pc, n_d)           // XOR D
>     CASE #xAB: RESULTIS z80XORr(pc, n_e)           // XOR E
>     CASE #xAC: RESULTIS z80XORr(pc, n_h)           // XOR H
>     CASE #xAD: RESULTIS z80XORr(pc, n_l)           // XOR L
>     CASE #xAE: RESULTIS z80XORr(pc, n_ihl)         // XOR (HL)
>     CASE #xAF: RESULTIS z80XORr(pc, n_a)           // XOR A
> 
>     CASE #xB0: RESULTIS z80ORr(pc, n_b)            // OR B
>     CASE #xB1: RESULTIS z80ORr(pc, n_c)            // OR C
>     CASE #xB2: RESULTIS z80ORr(pc, n_d)            // OR D
>     CASE #xB3: RESULTIS z80ORr(pc, n_e)            // OR E
>     CASE #xB4: RESULTIS z80ORr(pc, n_h)            // OR H
>     CASE #xB5: RESULTIS z80ORr(pc, n_l)            // OR L
>     CASE #xB6: RESULTIS z80ORr(pc, n_ihl)          // OR (HL)
>     CASE #xB7: RESULTIS z80ORr(pc, n_a)            // OR A
>     CASE #xB8: RESULTIS z80CPr(pc, n_b)            // CP B
>     CASE #xB9: RESULTIS z80CPr(pc, n_c)            // CP C
>     CASE #xBA: RESULTIS z80CPr(pc, n_d)            // CP D
>     CASE #xBB: RESULTIS z80CPr(pc, n_e)            // CP E
>     CASE #xBC: RESULTIS z80CPr(pc, n_h)            // CP H
>     CASE #xBD: RESULTIS z80CPr(pc, n_l)            // CP L
>     CASE #xBE: RESULTIS z80CPr(pc, n_ihl)          // CP (HL)
>     CASE #xBF: RESULTIS z80CPr(pc, n_a)            // CP A
> 
>     CASE #xC0: RESULTIS prbadop(pc)
>     CASE #xC1: RESULTIS z80POP16r(pc, n_bc)        // POP BC
>     CASE #xC2: RESULTIS prbadop(pc)
>     CASE #xC3: RESULTIS prbadop(pc)
>     CASE #xC4: RESULTIS prbadop(pc)
>     CASE #xC5: RESULTIS z80PUSH16r(pc, n_bc)       // PUSH BC
>     CASE #xC6: RESULTIS z80ADDrn(pc, n_a)          // ADD A,n
>     CASE #xC7: RESULTIS z80RSTn(pc, #x00)          // RST #x00
>     CASE #xC8: RESULTIS prbadop(pc)
>     CASE #xC9: RESULTIS z80RET(pc)                 // RET
>     CASE #xCA: RESULTIS prbadop(pc)
>     CASE #xCB: RESULTIS doz80instrCB(pc)           // CB instructions
>     CASE #xCC: RESULTIS prbadop(pc)
>     CASE #xCD: RESULTIS prbadop(pc)
>     CASE #xCE: RESULTIS z80ADCrn(pc, n_a)          // ADC A,n
>     CASE #xCF: RESULTIS z80RSTn(pc, #x08)          // RST #x08
> 
>     CASE #xD0: RESULTIS prbadop(pc)
>     CASE #xD1: RESULTIS z80POP16r(pc, n_de)        // POP DE
>     CASE #xD2: RESULTIS prbadop(pc)
>     CASE #xD3: RESULTIS prbadop(pc)
>     CASE #xD4: RESULTIS prbadop(pc)
>     CASE #xD5: RESULTIS z80PUSH16r(pc, n_de)       // PUSH DE
>     CASE #xD6: RESULTIS z80SUBn(pc)                // SUB n
>     CASE #xD7: RESULTIS z80RSTn(pc, #x10)          // RST #x10
>     CASE #xD8: RESULTIS prbadop(pc)
>     CASE #xD9: RESULTIS z80EXX(pc)                 // EXX
>     CASE #xDA: RESULTIS prbadop(pc)
>     CASE #xDB: RESULTIS prbadop(pc)
>     CASE #xDC: RESULTIS prbadop(pc)
>     CASE #xDD: RESULTIS doz80instrXD(pc, n_ix)     // DD and FD instructions
>     CASE #xDE: RESULTIS z80SBCrn(pc, n_a)          // SBC A,n
>     CASE #xDF: RESULTIS z80RSTn(pc, #x18)          // RST #x18
> 
>     CASE #xE0: RESULTIS prbadop(pc)
>     CASE #xE1: RESULTIS z80POP16r(pc, n_hl)        // POP HL
>     CASE #xE2: RESULTIS prbadop(pc)
>     CASE #xE3: RESULTIS z80EXrr(pc, n_isp, n_hl)   // EX (SP),HL
>     CASE #xE4: RESULTIS prbadop(pc)
>     CASE #xE5: RESULTIS z80PUSH16r(pc, n_hl)       // PUSH HL
>     CASE #xE6: RESULTIS z80ANDn(pc)                // AND n
>     CASE #xE7: RESULTIS z80RSTn(pc, #x20)          // RST #x20
>     CASE #xE8: RESULTIS prbadop(pc)
>     CASE #xE9: RESULTIS z80JPr(pc, n_ihl)          // JP (HL)
>     CASE #xEA: RESULTIS prbadop(pc)
>     CASE #xEB: RESULTIS z80EXrr(pc, n_de, n_hl)    // EX DE,HL
>     CASE #xEC: RESULTIS prbadop(pc)
>     CASE #xED: RESULTIS doz80instrED(pc, op)
>     CASE #xEE: RESULTIS z80XORn(pc)                // XOR n
>     CASE #xEF: RESULTIS z80RSTn(pc, #x28)          // RST #x28   The BCPL BRK instruction
> 
>     CASE #xF0: RESULTIS prbadop(pc)
>     CASE #xF1: RESULTIS z80POP16r(pc, n_af)        // POP AF
>     CASE #xF2: RESULTIS prbadop(pc)
>     CASE #xF3: RESULTIS z80DI(pc)                  // DI  Disable INT
>     CASE #xF4: RESULTIS prbadop(pc)
>     CASE #xF5: RESULTIS z80PUSH16r(pc, n_af)       // PUSH AF
>     CASE #xF6: RESULTIS z80ORn(pc)                 // OR n
>     CASE #xF7: RESULTIS z80RSTn(pc, #x30)          // RST #x30
>     CASE #xF8: RESULTIS prbadop(pc)
>     CASE #xF9: RESULTIS z80LD16rr(pc, n_sp, n_hl)  // LD SP,HL 
>     CASE #xFA: RESULTIS prbadop(pc)
>     CASE #xFB: RESULTIS z80EI(pc)                  // EI  Enable INT
>     CASE #xFC: RESULTIS prbadop(pc)
>     CASE #xFD: RESULTIS doz80instrXD(pc, n_iy)     // DD and FD instructions
>     CASE #xFE: RESULTIS z80CPn(pc)                 // CP n
>     CASE #xFF: RESULTIS z80RSTn(pc, #x38)          // RST #X38
>   }
> }
> 
> AND z80RSTn(pc, addr) = VALOF
> { IF addr=#x28 DO
>   { // This lists or execute the RST #x28 instruction.
>     // This is the BRK instruction used in the implementation
>     // of breakpoints.
>     // When executed it sets the faultcode to 2 and returns
>     // without advancing r_pc.
>     TEST pflag
>     THEN { writef("BRK")
>            RESULTIS 1
> 	 }
>     ELSE {
>            writef("z80RSTn: addy=%x2*n")
>            RESULTIS 2
>          }
>   }
> 
>   IF addr=#x38 DO
>   { // This lists or executes the RST instruction that causes a
>     // subroutine jump to location addr in page 0. If pflag=TRUE
>     // it lists the instruction returning its size in byte.
>     // If pflag=FALSE it executes the instruction pointed toby r_pc
>     // and return a fault code. If the instruction did not generate
>     // fault the result is zero.
>     // If addr is #x38 this subroutine looks at the bytes following
>     // the RST #x38 instruction to decide what to do. The inline
>     // arguments given to this subroutine are in the subsequent bytes.
>     // Each inline argument is either an 8 bit value encoded by a
>     // single byte, a 16 bit value encoded by a pair of bytes or an
>     // unsigned 16 bit even numbers encoded by one or two bytes as
>     // follows:
> 
>     // 0bbbbbbb          =>  00000000 0bbbbbbb
>     // 1bbbbbbb cccccccc =>  0ccccccc cbbbbbbb
> 
>     // This encoding was done in bcplcgz80.b as follows:
>   
>     //  LET low7   =  (value)       &  #B0000000001111111
>     //  LET high8  =  (value << 1)  &  #B1111111100000000
> 
>     //  TEST  high8 = 0  THEN  code_n_1( low7 )
>     //  ELSE
>     //  $(
>     //      code_n_1( low7 + #B10000000 )
>     //      code_n_1( high8 >> 8 )
>     //  $)
> 
>     // Other arguments are placed in the stack and results may also be
>     // placed there.
>     // The first inline argument is a byte specifying which operation to
>     // be perform. These operations are needed by the BCPL compiled code.
>     // Some examples are:      
>     //    0: m_apply
>     //    3: m_fixup
>     //    6: m_loadix
>     //    9: m_loadiy
> 
>     LET mtype = getbb(pc+1)
> 
>     SWITCHON mtype INTO
>     { DEFAULT: zerror("Bad RST #x38 op=%n*n", mtype)
>                RESULTIS 2
> 	     
>       CASE  m_apply:
>       { LET size = 3
>         LET arg = getbb(pc+2)
>         IF arg > #x7F DO size, arg := 4, arg & #x7F | getbb(pc+3)<<7 
>         TEST pflag
>         THEN { writef("APPLY %n", arg)
>                RESULTIS size
> 	     }
>         ELSE { pptr := pptr + arg // The new P pointer
>                putww(pptr, r_ix)
> 	       putww(pptr+1, r_pc+size)
> 	       r_ix := (pptr<<1)+128
> 	       r_pc := getr(n_hl)
> 	       RESULTIS 0
>              }
>       }
> 
>       CASE  m_fixup:
>         writef("FIXUP")
>         RESULTIS 2
>       
>       CASE  m_loadix:
>         writef("LOADIX")
>         RESULTIS 2
>     
>       CASE  m_loadiy:
>       { // Push G!arg
>         LET size = 3
>         LET arg = getbb(pc+2)
>         //writef("*nloadlvix: size=%n arg=%n*n", size, arg)
>         IF arg > #x7F DO size, arg := 4, (arg & #x7F) + (getbb(pc+3)<<7) 
>       
>         TEST pflag
>         THEN { writef("LOADIY %n", arg+128)
>                RESULTIS size
> 	     }
>         ELSE { r_sp := r_sp-2
>                putwb(r_sp, getww(gptr+arg+128))
> 	       r_pc := r_pc+size
> 	       RESULTIS 0
>              }
>       }
>       
>       CASE m_storeix:
>         zerror("STOREIX")
>         RESULTIS 2
>       
>       CASE m_storeiy:
>         writef("STOREIY")
>         RESULTIS 2
>       
>       CASE m_setlink0:
>         TEST pflag
>         THEN { writef("SETLINK0")
>                RESULTIS 2
> 	     }
>         ELSE { x_exx()
>                r_pc := r_pc+2
>                RESULTIS 0
> 	     }
> 
>       CASE 21:
>         TEST pflag
>         THEN { writef("SETLINK1")
>                RESULTIS 2
> 	     }
>         ELSE { x_exx()
>                putww(pptr+2, getr(n_hl))
>                r_pc := r_pc+2
>                RESULTIS 0
> 	     }
>         RESULTIS 2
>       
>       CASE m_setlink2:
>         TEST pflag
>         THEN { writef("SETLINK2")
>                RESULTIS 2
> 	     }
>         ELSE { x_exx()
>                putww(pptr+2, getr(n_hl))
>                putww(pptr+3, getr(n_de))
>                r_pc := r_pc+2
>                RESULTIS 0
> 	     }
>         RESULTIS 2
>       
>       CASE m_setlink3:
>         TEST pflag
>         THEN { writef("SETLINK3")
>                RESULTIS 2
> 	     }
>         ELSE { x_exx()
>                putww(pptr+2, getr(n_hl))
>                putww(pptr+3, getr(n_de))
>                putww(pptr+4, getr(n_bc))
>                r_pc := r_pc+2
>                RESULTIS 0
> 	     }
>         RESULTIS 2
> 
>       CASE m_return:
>         TEST pflag
>         THEN { writef("RETURN")
>                RESULTIS 2
> 	     }
>         ELSE { r_ix := getww(pptr)
> 	       r_pc := getww(pptr+1)
> 	       pptr := (r_ix-128)>>1
> 	       IF r_pc=0 DO
> 	       { //writef("Returning from start with result %n*n", getr(n_hl))
> 	         longjump(finp, finl)
> 	       }
> 	       //writef("doRSTn returning zero*n")
>                RESULTIS 0
> 	     }
> 
>       CASE m_finish:
>         TEST pflag
>         THEN { writef("FINISH")
>                RESULTIS 2
>              }
>         ELSE longjump(finp, finl) // Exit from z80emu
>       
>       CASE m_loadlvix:
>       { // Push ((IX-128)>>1) + arg
>         LET size = 3
>         LET arg = getbb(pc+2)
>         //writef("*nloadlvix: size=%n arg=%n*n", size, arg)
>         IF arg > #x7F DO size, arg := 4, (arg & #x7F) + (getbb(pc+3)<<7) 
>         //writef("loadlvix: size=%n IX-128=%n arg=%n*n", size, r_ix-128, arg)
>         //writef("loadlvix: result %n*n", ((r_ix-128)>>1)+arg)
>       
>         TEST pflag
>         THEN { writef("LOADLVIX %n", arg)
>                RESULTIS size
> 	     }
>         ELSE { r_sp := r_sp - 2
>                putwb(r_sp, pptr+arg)
> 	       r_pc := r_pc+size
> 	       RESULTIS 0
>              }
>       }
>       
>       CASE m_loadlviy:
>         writef("LOADLVIY")
>         RESULTIS 2
>       
>       CASE m_multiply:
>         writef("MULTIPLY")
>         RESULTIS 2
>       
>       CASE m_divide:
>         writef("DIVIDE");
>         RESULTIS 2
>       
>       CASE m_rem:
>         writef("REM")
>         RESULTIS 2
>     
>       CASE m_lshift:
>         writef("LSHIFT")
>         RESULTIS 2
>       
>       CASE m_rshift:
>         writef("RSHIFT")
>         RESULTIS 2
>       
>       CASE m_eq:
>         writef("EQ")
>         RESULTIS 2
>       
>       CASE m_ne:
>         writef("NE")
>         RESULTIS 2
>       
>       CASE m_ls:
>         writef("LS")
>         RESULTIS 2
>       
>       CASE m_gr:
>         writef("GR")
>         RESULTIS 2
>       
>       CASE m_le:
>         writef("LE")
>         RESULTIS 2
>       
>       CASE m_ge:
>         writef("GE")
>         RESULTIS 2
>       
>       CASE m_rdivide:
>         writef("RDIVIDE")
>         RESULTIS 2
>       
>       CASE m_rrem:
>         writef("RREM")
>         RESULTIS 2
>       
>       CASE m_rlshift:
>         writef("RLSHIFT")
>         RESULTIS 2
>       
>       CASE m_rrshift:
>         writef("RRSHIFT")
>         RESULTIS 2
>       
>       CASE m_abs:
>         writef("ABS")
>         RESULTIS 2
> 
>       CASE m_linsearch:
>       //       n K1 L1 ... Kn Ln Ldefault
>       //       n is popped from the stack
>       //       The other args are pointed to by HL
>       //       The value to switch on is in DE
>       //       n and the K values are always 2 bytes long
>       //       The L values are even addresses encoded in 1 or 2 bytes.
>         writef("LINSEARCH"); RESULTIS 2
> 
>       CASE m_sys:  // This is only used in the body of the function sys
>                    // which is:
> 	  	   //    RST #x38  m_setlink3
> 		   //    RST #x38  m_sys
> 		   //    RST #x38  m_return
> 		   // It calls z80sys() with pptr, gptr setup and the
> 		   // first three arguments, if present, are accessible
> 		   // by getr(n_hl), getr(n_de) and getr(n_bc).
>         TEST pflag
>         THEN { writef("SYS")
>                RESULTIS 2
> 	     }
>         ELSE { z80sys()
>                RESULTIS 0
> 	     }
> 
>     }
>   }
> 
>   writef("RST #x%x2 is not implemented*n",addr)
>   TEST pflag THEN RESULTIS 1
>              ELSE { r_pc:=r_pc+1; RESULTIS 0 }
>   
> }
> 
> AND z80sys() BE SWITCHON getr(n_hl) INTO
> { DEFAULT:
>     writef("*nERROR in z80sys: args %n %n %n %n*n",
>          getr(n_hl), getr(n_de), getr(n_bc), getww(pptr+5))
>     r_pc := r_pc+2
>     RETURN
> 
>   CASE 11: // sawrch
>     wrch(getr(n_de))
>     r_pc := r_pc+2
>     RETURN
> }
> 
> AND doz80instrCB(pc) = VALOF
> { LET op = getbb(pc+1)
>   LET bbb = op>>3 & 7   // bbb = 0 - 7
>   LET rrr = op & 7      // rrr = B C D E H L (HL) A
>   // 
>   // op = 00 000 rrr    RLC rrr
>   // op = 00 001 rrr    RRC rrr
>   // op = 00 010 rrr    RL  rrr
>   // op = 00 011 rrr    RR  rrr
>   // op = 00 100 rrr    SLA rrr    
>   // op = 00 101 rrr    SRA rrr
>   // op = 00 110 rrr              Error
>   // op = 00 111 rrr    SRL rrr
> 
>   // op = 01 bbb rrr    BIT bbb,rrr
>   // op = 10 bbb rrr    RES bbb,rrr
>   // op = 11 bbb rrr    SET bbb,rrr
> 
>   SWITCHON op>>6 INTO
>   { DEFAULT:
>     CASE #b00: 
>       SWITCHON bbb INTO
>       { DEFAULT:     RESULTIS zerror(pc, 2)
> 
>         CASE #b000:  RESULTIS z80RLCr(pc, rrr)  // RLC rrr
>         CASE #b001:  RESULTIS z80RRCr(pc, rrr)  // RCC rrr
>         CASE #b010:  RESULTIS z80RLr (pc, rrr)  // RL  rrr
>         CASE #b011:  RESULTIS z80RRr (pc, rrr)  // RR  rrr
>         CASE #b100:  RESULTIS z80SLAr(pc, rrr)  // SLA rrr
>         CASE #b101:  RESULTIS z80SRAr(pc, rrr)  // SRA rrr
>         CASE #b110:  RESULTIS zerror (pc, 2)
>         CASE #b111:  RESULTIS z80SRLr(pc, rrr)  // SRL rrr
>       } 
>     CASE #b01: RESULTIS z80BITbr(pc, bbb, rrr)  // BIT bbb,rrr
>     CASE #b10: RESULTIS z80RESbr(pc, bbb, rrr)  // RES bbb,rrr
>     CASE #b11: RESULTIS z80SETbr(pc, bbb, rrr)  // SET bbb,rrr
>   }
> }
> 
> AND doz80instrXD(pc, r) = VALOF // For op DD or FD
> { // Deal wilh DD and FD instructions,
>   // If op=DD r = n_ix
>   // If op=FD r = n_iy
>   LET d = getsbb(pc+2)
>   SWITCHON getbb(pc+1) INTO
>   { DEFAULT:   RESULTIS prbadop(pc)
>     CASE #x09: RESULTIS z80ADD16rr(pc, r, n_bc)       // ADD r,BC
>     CASE #x19: RESULTIS z80ADD16rr(pc, r, n_de)       // ADD r,DE
>     CASE #x29: RESULTIS z80ADDrr(pc, r, r)            // ADD r,r
>     CASE #x36: RESULTIS z80LDirdn(pc, r, d)           // LD (r+d),n
>     CASE #x39: RESULTIS z80ADDrr(pc, r, n_sp)         // ADD r,SP
>     CASE #x46: RESULTIS z80LDrird(pc, n_b, r, d)      // LD B,(r+d)
>     CASE #x4E: RESULTIS z80LDrird(pc, n_b, r, d)      // LD C,(r+d)
>     CASE #x56: RESULTIS z80LDrird(pc, n_d, r, d)      // LD D,(r+d)
>     CASE #x5E: RESULTIS z80LDrird(pc, n_e, r, d)      // LD E,(r+d)
>     CASE #x66: RESULTIS z80LDrird(pc, n_h, r, d)      // LD H,(r+d)
>     CASE #x6E: RESULTIS z80LDrird(pc, n_l, r, d)      // LD L,(r+d)
>     CASE #x70: RESULTIS z80LDirdr(pc, r, d, n_b)      // LD (r+d),B
>     CASE #x71: RESULTIS z80LDirdr(pc, r, d, n_c)      // LD (r+d),C
>     CASE #x72: RESULTIS z80LDirdr(pc, r, d, n_d)      // LD (r+d),D
>     CASE #x73: RESULTIS z80LDirdr(pc, r, d, n_e)      // LD (r+d),E
>     CASE #x74: RESULTIS z80LDirdr(pc, r, d, n_h)      // LD (r+d),H
>     CASE #x75: RESULTIS z80LDirdr(pc, r, d, n_l)      // LD (r+d),L
>     CASE #x77: RESULTIS z80LDirdr(pc, r, d, n_a)      // LD (r+d),A
>     CASE #x7E: RESULTIS z80LDrird(pc, n_a, r, d)      // LD A,(r+d)
>     CASE #x86: RESULTIS z80ADDrird(pc, n_a, r, d)     // ADD A,(r+d)
>     CASE #x8E: RESULTIS z80ADCrird(pc, n_a, r, d)     // ADC A,(r+d)
>     CASE #xA6: RESULTIS z80ANDird(pc, r, d)           // AND (r+d)
>     CASE #xE1: RESULTIS z80POP16r(pc, r)              // POP r
>     CASE #xE3: RESULTIS z80EXrr(n_isp, r)             // EX (SP),r
>     CASE #xE5: RESULTIS z80PUSH16r(r)                 // PUSH r
>   }
>   RESULTIS 0
> }
> 
> AND doz80instrXDCB(pc, r) = VALOF
> { // Deal with instructions:
>   // DD CB d op=00-4F Shifts, r = n_ix
>   // FD CB d op=00-4F Shifts, r = n_iy
> 
>   LET d  = getsbb(pc+2)
>   LET op = getbb(pc+3)
> 
>   //         00-07              RLC (r+d)        r = IX or IY
>   //         08-0F              RRC (r+d)        r = IX or IY
>   //         10-17              RL  (r+d)        r = IX or IY
>   //         18-1F              RR  (r+d)        r = IX or IY
>   //         20-27              SLA (r+d)        r = IX or IY
>   //         28-2F              SRA (r+d)        r = IX or IY
>   //         30-37              S?? 
>   //         38-3F              SRL (r+d)        r = IX or IY
>   // XF CB d op=40-7F =40+8*b+r BIT b,(r+d)      r = IX or IY
>   // XF CB d op=80-BF =80+8*b+r RES b,(r+d)      r = IX or IY
>   // XF CB d op=C0-FF =C0+8*b+r SET b,(r+d)      r = IX or IY
>   LET b = op>>6 & 7   // = 0 to 7
>   SWITCHON op>>6 INTO
>   { DEFAULT:
>     CASE 0: 
>       SWITCHON b INTO
>       { DEFAULT: RESULTIS zerror(pc, 2)
>         CASE 0:  RESULTIS z80RLCird(pc, r, d)  // RLC (r+d)
>         CASE 1:  RESULTIS z80RCCird(pc, r, d)  // RCC (r+d)
>         CASE 2:  RESULTIS z80RLird(pc, r, d)   // RL  (r+d)
>         CASE 3:  RESULTIS z80RRird(pc, r, d)   // RR  (r+d)
>         CASE 4:  RESULTIS z80SLAird(pc, r, d)  // SLA (r+d)
>         CASE 5:  RESULTIS z80SRAird(pc, r, d)  // SRA (r+d)
>         CASE 6:  RESULTIS zerror(pc, 4)       // S??
>         CASE 7:  RESULTIS z80SRLird(pc, r, d)  // SRL (r+d)
>       } 
>     CASE 1: RESULTIS z80BITbird(pc, b, r, d)   // BIT b,(r+d)
>     CASE 2: RESULTIS z80RESbird(pc, b, r, d)   // RES b,(r+d)
>     CASE 3: RESULTIS z80SETbird(pc, b, r, d)   // SET b,(r+d)
>   }
> }
> 
> AND doz80instrED(pc, op) = VALOF
> { SWITCHON getbb(pc+1) INTO
>   { DEFAULT:   RESULTIS prbadop(pc)
>     CASE #x40: RESULTIS z80INrr(pc, n_b, n_ic)       // IN B,(C)
>     CASE #x41: RESULTIS z80OUTrr(pc, n_ic, n_b)      // OUT (C),B
>     CASE #x42: RESULTIS z80SBCrr(pc, n_hl, n_bc)     // SBC HL,BC
>     CASE #x43: RESULTIS z80LD16innr(pc, getwb(pc+2), n_bc) // LD (nn),BC
>     CASE #x44: RESULTIS z80NEG(pc)                   // NEG
>     CASE #x45: RESULTIS z80RETN(pc)                  // RETN
>     CASE #x46: RESULTIS z80IMk(pc, 0)                // IM 0  Set INT Mode 0
>     CASE #x47: RESULTIS z80LDrr(pc, n_i, n_a)        // LD I,A
>     CASE #x48: RESULTIS z80INrr(pc, n_c, n_ic)       // IN C,(C)
>     CASE #x49: RESULTIS z80OUTrr(pc, n_ic, n_b)      // OUT (C),C
>     CASE #x4A: RESULTIS z80ADC16rr(pc, n_hl, n_bc)   // ADC HL,BC
>     CASE #x4B: RESULTIS z80LD16rinn(pc, n_bc, getwb(pc+2)) // LD BC,(nn)
>     CASE #x4D: RESULTIS z80RETI(pc)                  // RETI
>     CASE #x4F: RESULTIS z80LDrr(pc, n_r,n_a)         // LD R,A
>     CASE #x50: RESULTIS z80INrr(pc, n_d, n_ic)       // IN D,(C)
>     CASE #x51: RESULTIS z80OUTrr(pc, n_ic, n_d)      // OUT (C),D
>     CASE #x52: RESULTIS z80SBC16rr(pc, n_hl, n_de)   // SBC HL,DE
>     CASE #x53: RESULTIS z80LD16innr(pc, n_de)        // LD (nn),DE
>     CASE #x56: RESULTIS z80IMk(pc, 1)                // IM 1  Set IN Mode 1
>     CASE #x57: RESULTIS z80LDrr(pc, n_a, n_i)        // LD A,I
>     CASE #x58: RESULTIS z80INrr(pc, n_e, n_ic)       // IN E,(C)
>     CASE #x59: RESULTIS z80OUTrr(pc, n_ic, n_e)      // OUT (C),E
>     CASE #x5A: RESULTIS z80ADC16rr(pc, n_hl, n_de)   // ADC HL,DE
>     CASE #x5B: RESULTIS z80LD16rinn(pc, n_de)        // LD DE,(nn)
>     CASE #x5E: RESULTIS z80IMk(pc, 2)                // IM 2  Set INT Mode 2
>     CASE #x5F: RESULTIS z80LDrr(pc, n_a, n_r)        // LD A,R
>     CASE #x60: RESULTIS z80INrr(pc, n_h, n_ic)       // IN H,(C)
>     CASE #x61: RESULTIS z80OUTrr(pc, n_ic, n_h)      // OUT (C),H
>     CASE #x62: RESULTIS z80SBC16rr(pc, n_hl, n_hl)   // SBC HL,HL
>     CASE #x67: RESULTIS z80RRD(pc)                   // RRD
>     CASE #x68: RESULTIS z80INrr(pc, n_l, n_ic)       // IN L,(C)
>     CASE #x69: RESULTIS z80OUTrr(pc, n_ic, n_l)      // OUT (C),L
>     CASE #x6A: RESULTIS z80ADC16rr(pc, n_hl, n_hl)   // ADC HL,HL
>     CASE #x6F: RESULTIS z80RLD(pc)                   // RLD
>     CASE #x70: RESULTIS z80INrr(pc, n_f, n_ic)       // IN F,(C)
>     CASE #x72: RESULTIS z80SBC16rr(pc, n_hl, n_sp)   // SBC HL,SP
>     CASE #x73: RESULTIS z80LD16innr(pc, n_sp)        // LD (nn),SP
>     CASE #x79: RESULTIS z80OUTrr(pc, n_ic, n_a)      // OUT (C),A
>     CASE #x7A: RESULTIS z80ADC16rr(pc, n_hl, n_sp)   // ADC HL,SP
>     CASE #x7B: RESULTIS z80LD16rinn(pc, n_sp)        // LD SP,(nn)
>     CASE #xA0: RESULTIS z80LDI(pc)                   // LDI
>     CASE #xA1: RESULTIS z80CPI(pc)                   // CPI
>     CASE #xA2: RESULTIS z80INI(pc)                   // INI
>     CASE #xA3: RESULTIS z80OUTI(pc)                  // OUTI
>     CASE #xA8: RESULTIS z80LDD(pc)                   // LDD
>     CASE #xA9: RESULTIS z80CPD(pc)                   // CPD
>     CASE #xAA: RESULTIS z80IND(pc)                   // IND
>     CASE #xAB: RESULTIS z80OUTD(pc)                  // OUTD    CASE #xB0: RESULTIS z80LDIR(pc)                  // LDIR
>     CASE #xB1: RESULTIS z80CPIR(pc)                  // CPIR
>     CASE #xB2: RESULTIS z80INIR(pc)                  // INIR
>     CASE #xB3: RESULTIS z80OTIR(pc)                  // OTIR
>     CASE #xB8: RESULTIS z80LDDR(pc)                  // LDDR
>     CASE #xB9: RESULTIS z80CPDR(pc)                  // CPDR
>     CASE #xBA: RESULTIS z80INDR(pc)                  // INDR
>     CASE #xBB: RESULTIS z80OTDR(pc)                  // OTDR
>   //CASE #xC1: RESULTIS z80MULUBrr(pc, n_a, n_b)     // MULUB A,B
>                                                      // note C1+8*r
>   //CASE #xC3: RESULTIS z80MULUWrr(pc, n_hl, n_bc)   // MULUW HL,BC
>   //CASE #xF3: RESULTIS z80MULUWrr(pc, n_hl, n_sp)   // MULUW HL,SP
>   }
>   RESULTIS 0
> }
> 
> AND prbadop(pc) = VALOF
> { writef("*nInstruction at pc=%n not yet implemented: %x2 %x2 %x2 %x2*n",
>            pc, getbb(pc), getbb(pc+1), getbb(pc+2), getbb(pc+3))
>   val :=val+1
>   RESULTIS 1
> }
> 
> AND r2str(r) = VALOF SWITCHON r INTO
> { DEFAULT:    writef("r2str: Bad r=%n*n", r)
>               RESULTIS "??"
> 
>   CASE n_a:   RESULTIS "A"
>   CASE n_f:   RESULTIS "F"
>   CASE n_b:   RESULTIS "B"
>   CASE n_c:   RESULTIS "C"
>   CASE n_d:   RESULTIS "D"
>   CASE n_e:   RESULTIS "E"
>   CASE n_h:   RESULTIS "H"
>   CASE n_l:   RESULTIS "L"
>   CASE n_af:  RESULTIS "AF"
>   CASE n_bc:  RESULTIS "BC"
>   CASE n_de:  RESULTIS "DE"
>   CASE n_hl:  RESULTIS "HL"
>   CASE n_sp:  RESULTIS "SP"
>   CASE n_pc:  RESULTIS "PC"
>   CASE n_af1: RESULTIS "AF'"
>   CASE n_bc1: RESULTIS "BC'"
>   CASE n_de1: RESULTIS "DE'"
>   CASE n_hl1: RESULTIS "HL'"
>   CASE n_ic:  RESULTIS "(C)"
>   CASE n_ibc: RESULTIS "(BC)"
>   CASE n_ide: RESULTIS "(DE)"
>   CASE n_ihl: RESULTIS "(HL)"
>   CASE n_isp: RESULTIS "(SP)"
>   CASE n_ix:  RESULTIS "IX"
>   CASE n_iy:  RESULTIS "IY"
>   CASE n_m:   RESULTIS "M"
>   CASE n_nz:  RESULTIS "NZ"
>   CASE n_nc:  RESULTIS "NC"
>   CASE n_p:   RESULTIS "P"
>   CASE n_pe:  RESULTIS "PE"
>   CASE n_po:  RESULTIS "PO"
>   CASE n_z:   RESULTIS "z"
1818,1834d2640
< AND notyet(pc) = VALOF
< { // This prints an error message and
<   // returns the size of the offending insruction.
<   // It is only called when trying to execute an insruction.
<   LET size = 0
<   writef("*nInstruction is not yet implemented at %n: ", pc)
<   FOR i = 0 TO 3 DO writef("%x2 ", getbb(pc+i))
<   writef("   ")
<   //r_pc := pc+
<   size := prz80instr(pc)
<   newline()
<   abort(999)
<   singlestep := TRUE
<   tracing := TRUE
<   RESULTIS size
< }
< 
1840,1841c2646
< ELSE { notyet(pc)
<        putr(r, x_adc(getr(r), getr(s)))
---
> ELSE { putr(r, x_adc(getr(r), getr(s)))
1843c2648
<        RESULTIS 0
---
>        RESULTIS 1
1850,1851c2655
< ELSE { notyet(pc)
<        putr(r, x_adc(getr(r), getr(s)))
---
> ELSE { putr(r, x_adc(getr(r), getr(s)))
1853c2657
<        RESULTIS 0
---
>        RESULTIS 1
1860,1861c2664
< ELSE { notyet(pc)
<        putr(r, x_add(getr(r), getr(s)))
---
> ELSE { putr(r, x_add(getr(r), getr(s)))
1870,1871c2673
< ELSE { notyet(pc)
<        putr(r, x_add16(getr(r), getr(s)))
---
> ELSE { putr(r, x_add16(getr(r), getr(s)))
1880,1881c2682
< ELSE { notyet(pc)
<        putr(r, x_and(getr(r), getr(s)))
---
> ELSE { putr(r, x_and(getr(r), getr(s)))
1883c2684
<        RESULTIS 0
---
>        RESULTIS 1
1890,1891c2691
< ELSE { notyet(pc)
<        putr(n_a, x_xor(r_a, getr(r)))
---
> ELSE { putr(n_a, x_xor(r_a, getr(r)))
1896,1908d2695
< AND z80XORrird(pc,r, s) = VALOF
< { LET d = getbb(pc+1)
<   TEST pflag
<   THEN { writef("XOR %s,(%s+%s)", r2str(r), r2str(s), d)
<          RESULTIS 2
<        }
<   ELSE { notyet(pc)
<          putr(n_a, x_xor(r_a, getr(r)))
<          r_pc := r_pc+2
<          RESULTIS 0
<        }
< }
< 
1913,1914c2700
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1921,1922c2707
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1929,1930c2714
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1937,1938c2721
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1945,1946c2728
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1953,1954c2735
< ELSE { notyet(pc)
<        putr(r, getr(r)-1)
---
> ELSE { putr(r, getr(r)-1)
1958c2739
< AND z80DEC16r(pc, r, size) = VALOF TEST pflag
---
> AND z80DEC16r(pc, r) = VALOF TEST pflag
1960c2741
<        RESULTIS size
---
>        RESULTIS 1
1962,1964c2743
< ELSE { notyet(pc)
<        putr(r, getr(r)-1)
<        r_pc := pc+size
---
> ELSE { putr(r, getr(r)-1)
1972,1973c2751
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1980,1981c2758
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
1988,1989c2765
< ELSE { notyet(pc)
<        x_exx(pc)
---
> ELSE { x_exx(pc)
2005d2780
<        notyet(pc)
2016,2017c2791
< ELSE { notyet(pc)
<        writef("*nHALT instructions encountered*n")
---
> ELSE { writef("*nHALT instructions encountered*n")
2027,2028c2801
< ELSE { notyet(pc)
<        putr(r, getr(r) + 1)
---
> ELSE { putr(r, getr(r) + 1)
2037,2038c2810
< ELSE { notyet(pc)
<        putr(r, getr(r) + 1)
---
> ELSE { putr(r, getr(r) + 1)
2045,2051c2817,2819
<   TEST pflag THEN { writef("LD (%n),%s", nn, r2str(r))
<                     RESULTIS 3
< 		  }
<              ELSE { notyet(pc)
<                     putwb(nn, getr(r))
<                     RESULTIS 0
< 		  }
---
>   TEST pflag THEN writef("LD (%n),%s", nn, r2str(r))
>              ELSE putwb(nn, getr(r))
>   RESULTIS 3
2056,2062c2824,2826
<   TEST pflag THEN { writef("LD (%n),%s", nn, r2str(r))
<                     RESULTIS 3
<                   }
<              ELSE { notyet(pc)
<                     putwb(nn, getr(r))
<                     RESULTIS 0
< 		  }
---
>   TEST pflag THEN writef("LD (%n),%s", nn, r2str(r))
>              ELSE putwb(nn, getr(r))
>   RESULTIS 3
2077d2840
<          notyet(pc)
2097,2099c2860,2861
< ELSE { notyet(pc)
<        putr(r, getr(s))
<        r_pc := r_pc+1
---
> ELSE { putr(r, getr(s))
>        r_pc := r_pc+1 & #xFFFF
2107,2108c2869
< ELSE { notyet(pc)
<        r_pc := r_pc+1
---
> ELSE { r_pc := r_pc+1 & #xFFFF
2112c2873
< AND z80POP16r(pc, r, size) = VALOF TEST pflag
---
> AND z80POP16r(pc, r) = VALOF TEST pflag
2114c2875
<        RESULTIS size
---
>        RESULTIS 1
2118,2127c2879,2880
<        r_pc := pc+size
<        RESULTIS 0
<      }
< 
< AND z80RRA(pc) = VALOF TEST pflag
< THEN { writef("RRA")
<        RESULTIS 1
<      }
< ELSE { notyet(pc)
<        r_pc := r_pc+1 & #xFFFF
---
>        TEST r=n_ix | r=n_iy THEN r_pc := pc+2
>                             ELSE r_pc := pc+1
2135,2136c2888
< ELSE { notyet(pc)
<        r_pc := r_pc+1 & #xFFFF
---
> ELSE { r_pc := r_pc+1 & #xFFFF
2144,2157c2896
< ELSE { notyet(pc)
<        r_pc := getwb(r_sp)
<        r_sp := r_sp+2
<        RESULTIS 0
<      }
< 
< AND z80RETcc(pc, cc) = VALOF TEST pflag
< THEN { writef("RET")
<        RESULTIS 1
<      }
< ELSE { notyet(pc)
<        TEST evalcc(cc)
<        THEN r_pc := getwb(r_sp)
<        ELSE r_pc := pc+1
---
> ELSE { r_pc := getwb(r_sp)
2166,2167c2905
< ELSE { notyet(pc)
<        r_pc := getwb(r_sp)
---
> ELSE { r_pc := getwb(r_sp)
2172,2197c2910,2920
< AND z80ADDrn(pc,r) = VALOF TEST pflag
< THEN { writef("ADD %s,%n", r2str(r), getbb(pc+1))
<        RESULTIS 2
<      }
< ELSE { notyet(pc)
<        putr(r, getr(r) + getbb(pc+1))
<        r_pc :=r_pc+2 & #xFFFF
<        RESULTIS 0
<      }
< 
< AND z80SUBrird(pc, r, s) = VALOF
< { LET d = getsbb(pc+2)
<   TEST pflag
<   THEN { LET rstr = r2str(r)
<          LET sstr = r2str(s)
<          TEST d<0
<          THEN writef("SUB %s,(%s%n", rstr, sstr, d)
<          ELSE writef("SUB %s,(%s+%n", rstr, sstr, d)
<          RESULTIS 3
<        }
<   ELSE { LET res = getr(r)+getr(s)
<          notyet(pc)
<          putr(r, res)
<          r_pc := pc+3
<          RESULTIS 0
<        }
---
> AND z80ADDrn(pc,r) = VALOF
> { IF pflag DO
>   { writef("ADD %s,%n", r2str(r), getbb(pc+1))
>     RESULTIS 2
>   }
>   //abort(6534)
>   putr(r, getr(r) + getbb(pc+1))
>   //abort(6535)
>   
>   r_pc :=r_pc+2 & #xFFFF
>   RESULTIS 0
2204,2206c2927,2928
< ELSE { LET res = x_sbc(getr(r), getr(s), r_fc)
<        notyet(pc)
<        res := res-1
---
> ELSE { LET res = getr(r)+getr(s)
>        IF (r_f & fb_c)>0 DO res := res-1
2216,2217c2938
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2224,2225c2945
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2232,2233c2952
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2240,2241c2959
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2248,2249c2966
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2256,2257c2973
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2264,2265c2980
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2272,2273c2987
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2280,2281c2994
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2288,2289c3001
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2296,2297c3008
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2304,2305c3015
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2312,2313c3022
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2320,2321c3029
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2328,2329c3036
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2336,2337c3043
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2344,2345c3050
< ELSE { notyet(pc)
<        putr(r, getbb(pc+1))
---
> ELSE { putr(r, getbb(pc+1))
2351c3056
< THEN { writef("LD %s,%n", r2str(r), getswb(pc+1))
---
> THEN { writef("LD %s,%n", r2str(r), getwb(pc+1))
2354c3059
< ELSE { putr(r, getswb(pc+1))
---
> ELSE { putr(r, getwb(pc+1))
2363,2364c3068,3069
< ELSE { notyet(pc)
<        r_a := r_a | getr(r)
---
> ELSE { r_a := r_a | getr(r)
>        r_f := r_f & fb_np
2369,2383d3073
< AND z80ORird(pc, r) = VALOF
< { LET d = getsbb(pc+2)
<   TEST pflag
<   THEN { TEST d<0
<          THEN writef("OR (%s%n)", r2str(r), d)
<          ELSE writef("OR (%s+%n)", r2str(r), d)
<          RESULTIS 3
<        }
<   ELSE { notyet(pc)
<          r_a := r_a | getr(r)
<          r_pc := r_pc+3 & #xFFFF
<          RESULTIS 0
<        }
< }
< 
2388,2389c3078
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2396,2397c3085
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2400,2401c3088,3089
< AND z80PUSH16r(pc, r, size) = VALOF TEST pflag
< THEN { writef("PUSH %s", r2str(r))
---
> AND z80RCCr(pc, r) = VALOF TEST pflag
> THEN { writef("RCC %s", r2str(r))
2404,2405c3092
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2408,2409c3095,3096
< AND z80RRCr(pc, r) = VALOF TEST pflag
< THEN { writef("RRC %s", r2str(r))
---
> AND z80RESbr(pc, b, r) = VALOF TEST pflag
> THEN { writef("RES %n, %s", r2str(r))
2412,2413c3099
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2416,2417c3102,3103
< AND z80RESbr(pc, b, r) = VALOF TEST pflag
< THEN { writef("RES %n, %s", r2str(r))
---
> AND z80RLCr(pc, r) = VALOF TEST pflag
> THEN { writef("RLC %s", r2str(r))
2420,2421c3106
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2424c3109
< AND z80RLCr(pc, r) = VALOF TEST pflag
---
> AND z80RRCr(pc, r) = VALOF TEST pflag
2428,2429c3113
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2436,2437c3120
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2446,2447c3129
<        notyet(pc)
<        r_fc := w&1
---
>        r_fc := (w&1)>0 -> fb_c, 0
2451,2452c3133,3136
<        r_fval := w
<        r_fhval := w
---
>        r_fs := w<0 -> fb_s, 0
>        r_fz := w=0 -> fb_z, 0
>        r_fh := 0
>        r_fv := parity(w)
2462,2463c3146
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2470,2471c3153
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2479,2480c3161,3162
<        notyet(pc)
<        r_fc := w&1
---
>        r_fc := 0
>        IF (w&1)>0 DO r_fc := fb_c
2482,2483c3164,3167
<        r_fval := 0
<        r_fhval := w
---
>        r_fs := 0
>        IF w=0 DO r_fz := fb_z
>        r_fh := 0
>        r_fv := parity(w)
2495,2496c3179
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 2)
2505,2508c3188,3190
<        notyet(pc)
<        putr(r, getr(r) + getbb(a) + r_fc)
<        r_pc := r_pc+3
<        RESULTIS 0
---
>        putr(r, getr(r) + getbb(a) + (fb_c & r_f))
>        r_pc := r_pc+3 & #xFFFF
>        RESULTIS 3
2517,2518c3199
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2526,2527c3207
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 1)
2558,2559c3238
<   ELSE { notyet(pc)
<          putr(r, getwb(w))
---
>   ELSE { putr(r, getwb(w))
2571,2572c3250
<   ELSE { notyet(pc)
<          putr(r, getwb(w))
---
>   ELSE { putr(r, getwb(w))
2574,2580d3251
<          RESULTIS 0
<        }
< }
< 
< AND z80LDIr(pc, r) = VALOF
< { TEST pflag
<   THEN { writef("LDI %s", r2str(r))
2583,2599d3253
<   ELSE { notyet(pc)
<          putr(r, r_i)
<          r_pc := r_pc+2 & #xFFFF
<          RESULTIS 0
<        }
< }
< 
< AND z80LDRr(pc, r) = VALOF
< { TEST pflag
<   THEN { writef("LDI %s", r2str(r))
<          RESULTIS 3
<        }
<   ELSE { notyet(pc)
<          putr(r, r_r)
<          r_pc := r_pc+2 & #xFFFF
<          RESULTIS 0
<        }
2606,2607c3260
< ELSE { r_pc := pc+notyet(pc)
<        RESULTIS 0
---
> ELSE { RESULTIS zerror(pc, 4)
2612,2625c3265,3270
< AND evalcc(cc) = VALOF SWITCHON cc INTO
< { DEFAULT:    writef("evalcc: Bad cc=%n*n", cc)
<               abort(999)
< 	      RESULTIS FALSE
<   CASE cc_m:  RESULTIS r_fval<0
<   CASE cc_c:  RESULTIS r_fc>0
<   CASE cc_nc: RESULTIS r_fc=0
<   CASE cc_nz: RESULTIS r_fval~=0
<   CASE cc_p:  RESULTIS parity(r_fval)=0
<   CASE cc_pe: RESULTIS parity(r_fval)=0
<   CASE cc_po: RESULTIS parity(r_fval)=0
<   CASE cc_z:  RESULTIS r_fval=0
< 
< }
---
> AND setparity(w) = VALOF
> { IF w=0 DO { r_f := r_f & fb_np; RETURN } // set P=0
>   w := w & (w-1)
>   IF w=0 DO { r_f := r_f | fb_p; RETURN }  // Set P=1
>   w := w & (w-1)  
> } REPEAT
2629c3274
<   IF r_fc DO res := res + 1
---
>   IF (r_f & fb_c)>0 DO res := res + 1
2635c3280
<   IF r_fc DO res := res + 1
---
>   IF (r_f & fb_c)>0 DO res := res + 1
