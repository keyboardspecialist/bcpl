      1  // This is the BCPL compiler front end used with several
     58  // codegenerators including those for 32- and 64-bit Cintcode.
    121  
    122  // Implemented by Martin Richards (c) 10 Dec 2018
    172  
    173  /* Change history
    191  
    192  01/10/2020
    203  Added option T16 to allow the frontend to be used with codegenerators
    273  for 16 bit machines such as the Z80.
    310  
    311  11/12/2018
    322  Major addition to standard BCPL, including operators such as <>, #:=
    391  and the op:= operators with corresponding additions to the FLT
    454  feature. For example x, y +:= 1, 1.0 is allowed and automatically
    520  compiled as { x := x+1; y := y#+1.0 }.  The manual has not yet been
    588  updated to reflect the change. This change is intended to eliminate
    656  the need for the xbcpl compiler which is now out of date.
    714  
    715  26/11/2018
    726  I am about to make some modifications and extensions to standard BCPL
    796  with the aim of removing the need to keep the xbcpl compiler. The
    862  first change is the removal of old redundant system words that were
    930  require in 1967 when BCPL was first implemented. At the time character
   1001  sets were very limited but since about 1972 most BCPL systems use the
   1071  ASCII character set. The system words that have been removed are: EQ
   1140  GE GR LV LE LS LOGOR LOGAND LSHIFT NE OR RSHIFT and RV. These were
   1207  removed by commenting out the relevant calls of dsw in
   1262  declsyswords. It is easy to correct any program that still uses any of
   1333  them, alternatively, undo the comments in declsyswords. REM and NEQV
   1402  are still synonyms of MOD and XOR.
   1437  
   1438  06/11/2018
   1449  There are new OCODE operators SELLD and SELST to improve the
   1510  efficiency of the OF operator. The compiler option NOSELST causes the
   1580  compiler to generate OCODE that does no use these operators. Although
   1650  SIAL now has the selld and selst instructions not all SIAL
   1709  codegenerators have been suitably modified.
   1753  
   1754  27/08/2018
   1765  Systematically replaced s_fnumber by s_fnum.
   1810  
   1811  18/08/2018
   1822  Define sourcenamev only in bcplfe.b and not in bcplfecg.h.
   1881  
   1882  02/03/2018
   1893  Added the FLT feature to make floating point operations more
   1954  convenient.  It allows some variables to be given the FLT tag and use
   2024  these variables to cause some integer operators to be replaced by
   2090  their floating point versions. See bcplman.pdf for details.
   2150  
   2151  08/10/2014
   2162  Slightly modified the translation of switchon commands to use
   2224  the OCODE operators RES and Rstack. This change was made to simplify
   2293  the optimisation of Sial.
   2319  
   2320  06/08/2014
   2331  Added floating point numbers and the operators FIX FLOAT #ABS #* #/
   2399  #MOD #+ #- #= #~= #< #> #<= #>=. This version of the compiler
   2461  generates Cintcode that runs under the standard Cintcode interpreter
   2530  (which was modified for xbcpl in 2010), and it is compatible with
   2596  procode.  bcplcgsial.b, sial-sasm.b have been modified appropriately,
   2666  but sial-386.b and sial-arm.b will need modification. This version
   2733  allows 32-bit manifest floating point constants when running under
   2800  32-bit Cintcode and 64-bit floating point when running unser 64-bit
   2868  Cintcode.  It uses the standard IEEE floating point formats.
   2929  
   2930  19/04/2014
   2941  Systematically changed mult to mul, plus to add and minus to sub.
   3007  
   3008  30/04/2014
   3019  Do not increment line number on *p for compatiblity with emacs.
   3083  
   3084  05/02/2014
   3095  Allow // comments in multi-line string constants.
   3145  
   3146  08/01/2014
   3157  Added $~tag ... $>tag conditional compilation feature to allow
   3220  code to be included if a conditional tag is not set..
   3274  
   3275  03/12/2013
   3286  Added the compiler option OPT/K to set conditional compilation
   3349  options. The argument is a string of option names consisting of
   3413  letters, digits, underlines and dots separated by plus signs or
   3477  indeed any characters not allowed in option names.
   3528  
   3529  13/05/2013
   3540  This is a version of the BCPL compiler front end is used by many
   3605  variants of the compiler including those that generate 32- or
   3667  64-cintcode.  It is designed to run on both 32- and 64-bit
   3726  systems. The options t32 and t64 specify the bit length of the BCPL
   3794  word in the target system. The default is the same as that of the
   3860  current system.  On 64-bit systems numerical constants are compiles to
   3931  full precision, but on 32-bit systems they are truncated to 32 bits
   3999  then sign extended to 64 bits. 64-bit Cintcode has one new instruction
   4070  (MW) that sets a new 64 bit register called MW that is used to modify
   4140  the operand of the next W type instruction (KW, LLPW, LW, LPW, SPW,
   4208  APW and AW). The MW instruction has a 32 bit operand that is placed in
   4279  the senior half of the MW register. The junior half is cleared.  MW is
   4350  added to the operand of any W type instruction and is immediately
   4416  cleared after use.
   4435  
   4436  18/01/2011
   4447  If VER and XREF are both specified, verification output is opened
   4513  using findappend. 
   4532  
   4533  05/01/2011
   4544  Modified g/bcplfecg.h to be usable by bcpl.b, xbcpl.b and procode.b
   4612  
   4613  05/10/2010
   4624  Modified the treatment of EQCASES to preserve the case of the first
   4692  occurrence of each name for use in eg cross reference listings.
   4756  Removed SKIP reserved word, {} can be used instead.
   4808  
   4809  20/10/09
   4818  Corrected bug in performget relating to sourcefile names and
   4879  numbers.
   4888  
   4889  10/07/2009
   4900  Stopped '.' terminating GET streams so that GET streams can contain
   4968  several sections separated by dots. BEWARE: this is an incompatible
   5036  change, since the first section of a GET stream has in the past been
   5105  used as a header.
   5123  Re-organised the compiler into g/bcplfecg.h, bcplfe.b and bcplcgcin.b,
   5194  and reallocating most of the compiler globals.
   5241  
   5242  08/05/2009
   5253  Increased the default treesize to 200000.
   5295  
   5296  03/07/2007
   5307  Modified the treatment of *# escapes in string and character constants
   5378  to allow both UTF8 and GB2312 encoding. Added compiler options UTF8
   5446  and GB2312 to set the default encoding. *#U and *#G in a string and
   5514  character constant temporarily set the encoding to UTF8 and GB2312,
   5582  respectively, overriding the default setting. In GB2312 mode, *#dddd
   5651  contains up to 4 decimal digits. See the BCPL manual.
   5705  
   5706  27/06/2007
   5717  Added the Unicode escape sequences *#hhhh and *##hhhhhhhh to string
   5785  and character constants. Within string they are converted to the
   5850  corresponding UTF8 sequence of bytes and within a character constant
   5919  they yield the corresponding Unicode integer. See the last few tests
   5988  in com/cmpltest.b
   6006  
   6007  27/07/2006
   6018  Changed the implementation of the GET directive to make it system
   6084  independent. Performget now obtains the headers environment variable
   6153  from the root node (rootnode!rtn_hdrsvar) this is normally either
   6219  "BCPLHDRS" or "POSHDRS". If the header file does not end in .h or .b,
   6289  .h is appended. The search order is as follows:
   6337  
   6338  (1) The current directory.
   6365  (2) The directories specified by the headers environment variable,
   6432      if set.
   6444  (3) The subdirectory g/ of the root specified by the environment
   6509      variable rootnode!rtn_rootvar, if set.
   6552  
   6553  05/04/2006
   6564  Correcteded a bug in trans concerning the tranlation of SKIP.
   6626  
   6627  18/01/2006
   6638  Based on Dave Lewis's suggestion, in outputsection(), added:
   6699     IF objline1%0 DO writef("%s*n", objline1)
   6744  where objline1 is the first line of file objline1 if it can be found
   6813  in the current directory or in the HDRS directory. This will typically
   6884  put a line such as:
   6904  #!/usr/local/bin/cintsys -c
   6932  as the first line of the compiled object module. This line is ignored
   7002  by the CLI but may be useful under Linux. If objline1 cannot be found
   7072  no such line is inserted at the start of the object module.
   7132  
   7133  30/8/2005
   7143  Defined the function default_hdrs() near the start to allow easy change
   7215  from cintsys to cintpos versions of the compiler.
   7265   
   7267  22/6/2005
   7277  Added the command SKIP and let empty blocks be equivalent to
   7338  SKIP. Empty section brackets are now also allowed after MANIFEST,
   7404  STATIC and GLOBAL.  These changes make program development marginally
   7474  easier.
   7482  
   7483  17/6/2004
   7493  Made GET first look in the current directory.
   7539  Added bcpl command option HDRS to allow the environment variable
   7604  specifying the headers directory to be changed. The default is
   7667  BCPLHDRS.
   7677  
   7678  23/4/2004
   7688  Updated the standard BCPL compiler with all the Cintpos extensions
   7755  including cross referencing and 11 character names.
   7807  Make GET directives use the BCPLHDRS environment variable.
   7866  
   7867  11/6/2002
   7877  Changed square brackets to mean subscription with same precedence
   7943  and function calls.
   7963  
   7964  18/3/2002
   7974  Use BCPLHDRS and BCPLPATH in GET directives.
   8019  
   8020  14/1/2002
   8030  Added XREF option to output name information during compilation.
   8095  
   8096  11/7/2001
   8106  Added language extensions for the Ford dialect of BCPL.
   8162  i.e. modified performget
   8187       added SLCT and OF (also ::)
   8220       added || comments
   8243       treesize set to 100000
   8271  
   8272  15/1/2001
   8282  Complain if global number is larger than 65535.
   8330  
   8331  10/8/2000
   8341  Change the maximum number of error messages from 30 to 10.
   8400  
   8401  14/12/1999
   8412  Made / * ... * /  comments nest.
   8445  Allow the constants in MANIFEST, STATIC and GLOBAL declarations 
   8510  to be optional. If absent the value is one greater than the
   8570  previous value. Unless specified the first value is zero, so
   8631  MANIFEST { a; b=10; c } declares a, b and c to be 0, 10 and 11,
   8695  respectively.
   8709  
   8710  09/06/1999
   8721  Made changes to buffer OCODE in memory. When bcpl is called
   8781  without the TO argument it writes numeric ocode to the file ocode.
   8848  Lex treats CR (13) correctly to improve convenience when running
   8913  under Windows and WindowsCE.
   8942  
   8943  26/02/1999
   8954  Added BIN option to the compiler to generate a binary (rather than
   9021  hex) hunk format for the compiled code. This is primarily for the
   9087  Windows CE version of the cintcode system where compactness is
   9150  particularly important. There is a related change to loadseg in
   9214  cintmain.c
   9225  
   9226  17/11/1998
   9237  Changed the workspacesize to 40000 and added the SIZE keyword
   9299  to allow the user to specify this size.
   9339  
   9340  9/11/1998
   9350  Made GET directives search the current working directory
   9407  then directories given by the shell variable BCPLPATH, if set.
   9470  It uses the BLIB function pathfindinput.
   9511  
   9512  15/12/1996
   9523  Correct a bug in cellwithname.
   9554  
   9555  16/08/1996
   9566  Added one line to readnumber to allow underscores in numbers after 
   9634  the first digit.
   9651  
   9652  07/06/1996
   9663  Implemented the method application operator for object oriented
   9727  programming in BCPL. E # (E1, E2,..., En) is equivalent to
   9786  ((!E1)!E)(E1, E2,..., En)
   9812  
   9813  24/12/1995
   9824  Improved the efficiency of cellwithname in TRN (using the hash chain
   9893  link in name node).
   9913  Improved the efficiency of outputsection in CG by introducing
   9975  wrhex2 and wrword_at.
   9997  
   9998  24/07/1995
  10009  Removed bug in atbinfo, define addinfo_b change some global numbers.
  10078  Implement constant folding in TRN.
  10113  
  10114  13/07/1995
  10125  Allowed { and } to represent untagged section brackets.
  10181  
  10182  22/06/1993
  10193  Reverse order in SWB and have a minimum of 7 cases
  10244  to allow faster interpreter.
  10273  
  10274  02/06/1993
  10285  Changed code for SWB to use heap-like binary tree.
  10336  
  10337  19/05/1993
  10348  Put in code to compile BTC and XPBYT instructions.
  10399  
  10400  23/04/1993
  10411  Allowed the codegenerator to compiler the S instruction.
  10468  
  10469  21/12/1992
  10480  Cured bug in compilation of (b -> f, g)(1,2,3)
  10527  
  10528  24/11/1992 
  10540  Cured bug in compilation of a, b := s%0 > 0, s%1 = '!'
  10595  
  10596  23/07/1992:
  10608  Renamed nextlab as newlab, load as loadval in the CG.
  10662  Put back simpler hashing function in lookupword.
  10711  Removed rdargs fudge.
  10733  Removed S2 compiler option.
  10761  Cured bug concerning the closing of gostream when equal to stdout.
  10828  */
  10831  
  10832  SECTION "BCPL"
  10847  
  10848  GET "libhdr"
  10861  GET "bcplfecg"
  10876   
  10878  LET default_hdrs() = VALOF // Changed MR 12/07/09
  10928  { LET hdrs = rootnode!rtn_hdrsvar // Typically "BCPLHDRS" or "POSHDRS" or 0
  11004    IF hdrs RESULTIS hdrs
  11028    // The following is only executed if cintsys or cintsys64 fails to set
  11101    // the hdrs field in the rootnode.
  11138    // Note that tcb=0 when running under cintsys.
  11187    TEST t64
  11198    THEN RESULTIS tcb -> "POS64HDRS", "BCPL64HDRS"
  11247    ELSE RESULTIS tcb -> "POSHDRS",   "BCPLHDRS"
  11294  }
  11296  
  11297  GLOBAL {
  11306  // Globals used in LEX
  11329  chbuf:feg
  11339  decval; fltval; exponent; getstreams; charv
  11383  hdrs  // MR 10/7/04
  11403  
  11404  workvec
  11412  readdecimal; readnumber; rdstrch
  11445  token; wordnode; ch
  11465  rdtag; performget
  11483  lex; dsw; declsyswords; nlpending
  11517  lookupword; eqlookupword; rch
  11547  sourcenamev; sourcefileno; sourcenamevupb
  11589  skiptag; wrchbuf; chcount; lineno
  11623  nulltag; rec_p; rec_l
  11645   
  11647  // Globals used in SYN
  11670  rdblockbody;  rdsect
  11691  rnamelist; rname
  11708  rdef; rcom
  11719  rdcdefs
  11727  formtree; synerr//; opname       declared in bcplfecg.h
  11783  rexplist; rdseq
  11799  mk1; mk2; mk3
  11813  mk4; mk5; mk6; mk7
  11832  mk3list               // Free list of nodes of size 3
  11886  unmk3                 // Return a node of size 3
  11935  newvec
  11942  rnexp; rexp; rbexp
  11961  
  11962  calib
  11968  }
  11970   
  11972   
  11974  MANIFEST {
  11985  c_backspace =  8
  12002  c_tab       =  9
  12019  c_newline   = 10
  12036  c_newpage   = 12
  12053  c_return    = 13
  12070  c_escape    = 27
  12087  c_space     = 32
  12104  }
  12106  
  12107  LET floatingchk() BE
  12128  { TEST t64
  12139    THEN UNLESS ON64 DO
  12161           synerr("64-bit floating point constants cannot be compiled using 32 bit BCPL")
  12249    ELSE IF ON64 DO
  12267           synerr("32-bit floating point constants cannot be compiled using 64 bit BCPL")
  12355  }
  12357   
  12359  LET start() = VALOF
  12379  { LET treesize = 0
  12398    AND argv = VEC 50
  12418    AND argform = "FROM/A,TO/K,VER/K,SIZE/K/N,TREE/S,NONAMES/S,*
  12481                  *D1/S,D2/S,OENDER/S,EQCASES/S,BIN/S,XREF/S,GDEFS/S,HDRS/K,*
  12557                  *GB2312/S,UTF8/S,SAVESIZE/K/N,HARD/S,*
  12612                  *T16/S,T32/S,T64/S,OPT/K,TREE2/S,NOSELST/S,MAP/K,LIST/K"
  12685    // T16, t32, MAP and LIST added by MR 01/10/2020
  12736    LET stdout = output()
  12760    LET objline1vec = VEC 256/bytesperword+1
  12803    LET optstringvec = VEC 256/bytesperword+1
  12847    objline1 := objline1vec
  12873    objline1%0 := 0
  12891    optstring := optstringvec
  12919    optstring%0 := 0
  12938    errmax   := 10
  12955    errcount := 0
  12971    fin_p, fin_l := level(), fin
  13002  
  13003    flt0  := sys(Sys_flt, fl_mk, 0, 0)
  13040    flt1  := sys(Sys_flt, fl_mk, 1, 0)
  13077    flt10 := sys(Sys_flt, fl_mk, 10, 0)
  13115  
  13116    treevec      := 0
  13136    obuf         := 0
  13156    sourcestream := 0
  13176    ocodeout     := 0
  13196    gostream     := 0
  13216    getstreams   := 0
  13236  
  13237    sysprint := stdout
  13258    selectoutput(sysprint)
  13283   
  13285     // Allocate vector for source file names
  13329    sourcenamevupb := 1000
  13354    sourcenamev := getvec(sourcenamevupb)
  13394    UNLESS sourcenamev DO
  13418    { writef("Insufficient space available*n")
  13463  abort(999)
  13474      errcount := 1
  13492      GOTO fin
  13505    }
  13509    sourcefileno := 0
  13529    FOR i = 0 TO sourcenamevupb-1 DO sourcenamev!i := 0  // Corrected 19/08/2018   
  13611   
  13613    // Set the current system wordlength flag
  13657    // ON64 is defined in libhdr.h. Previously called c64.
  13714  
  13715    // Set the target system wordlength flag
  13758    t64 := ON64 // Set the default target word length
  13810  
  13811    IF rdargs(argform, argv, 50)=0 DO { writes("Bad arguments*n")
  13875                                        errcount := 1
  13927                                        GOTO fin
  13974                                      }
  14012  
  14013    bigender := (!"AAAAAAA" & 255) ~= 7    // =TRUE if on a bigender m/c
  14084  
  14085    t16, t32, t64, wordbytelen, wordbitlen := FALSE, TRUE, FALSE, 4, 32  // T32 is the default setting
  14186    
  14189    IF argv!18 DO                           // T16/S
  14240    { t16, t32, t64, wordbytelen, wordbitlen :=  TRUE, FALSE, TRUE, 2, 16
  14312      IF argv!19 | argv!20 DO
  14340      { writef("Only one of T16, T32 or T64 is allowed*n")
  14397        RESULTIS 0
  14414      }
  14420    }
  14424    IF argv!19 DO                           // T32/S
  14475    { t16, t32, t64, wordbytelen, wordbitlen := FALSE, TRUE, FALSE, 4, 32
  14547      IF argv!20 DO
  14565      { writef("Only one of T16, T32 or T64 is allowed*n")
  14622        RESULTIS 0
  14639      }
  14645    }
  14649    IF argv!20 DO                           // T64/S
  14700    { t16, t32, t64, wordbytelen, wordbitlen :=  FALSE, FALSE, TRUE, 8, 64
  14773    }
  14777  
  14778    writef("*n%n bit BCPL (10 Oct 2020) %n bit target*n", bitsperword, wordbitlen)
  14859  
  14860    IF argv!21 DO                           // OPT/K
  14911    { LET s = argv!20
  14931      FOR i = 0 TO s%0 DO optstring%i := s%i
  14974  //writef("*nopt=%s*n", optstring)
  15008    }
  15012    treesize := 200_000
  15034    IF argv!3 DO treesize := !argv!3        // SIZE/K/N
  15088    IF treesize<10_000 DO treesize := 10_000
  15131    obufsize := treesize/2
  15156  
  15157    prtree        := argv!4                 // TREE/S
  15209    savespacesize := 3
  15230  
  15231    // Code generator options 
  15260    naming := TRUE
  15277    debug := 0
  15290  
  15291    // This must be done after T64 is properly set
  15340    hdrs := default_hdrs()                  // Set the default HDRS
  15406  
  15407    IF argv!5 DO naming   := FALSE          // NONAMES/S
  15462    IF argv!6 DO debug    := debug+1        // D1/S
  15512    IF argv!7 DO debug    := debug+2        // D2/S
  15562    IF argv!8 DO bigender := ~bigender      // OENDER/S
  15616    eqcases  := argv!9                      // EQCASES/S
  15671    bining   := argv!10                     // BIN/S (binary hunk)
  15736    xrefing  := argv!11                     // XREF/S
  15788    gdefsing := argv!12                     // GDEFS/S
  15841    IF argv!13 DO hdrs := argv!13           // HDRS/K
  15893    defaultencoding := UTF8
  15919    IF argv!14 DO defaultencoding := GB2312 // GB2312/S
  15973    IF argv!15 DO defaultencoding := UTF8   // UTF8/S
  16025    encoding := defaultencoding
  16055    IF argv!16 DO savespacesize := !(argv!16) // SAVESIZE/K/N
  16115    hard := argv!17                         // HARD/S
  16167                                            // t16/S is 18
  16224                                            // t32/S is 19
  16281                                            // t64/S is 20
  16338                                            // OPT   is 21
  16395    prtree2 := argv!22                      // TREE2/S -- print tree after trans
  16474                                            // to test the FLT feature.
  16544  
  16545    noselst := argv!23                      // NOSELST/S
  16600                                            // Do not generate SELLD or
  16670                                            // SELST Ocode instructions.
  16741  
  16742    mapfilename  := argv!24                  // MAP/K     For the Z80 codegenerator
  16824    listfilename := argv!25                  // LIST/K    and possibly others
  16900  
  16901    // Added 5/10/2010
  16922    IF eqcases DO lookupword := eqlookupword
  16965  
  16966  //writef("BCPL hdrs = %s*n", hdrs)
  17001  IF noselst DO writef("NOSELST option was given*n")
  17052  
  17053    { // Feature added by MR 17/01/06
  17089      // If file objline1 can be found, its first line will be written
  17158      // at the start of the compiled Cintcode file. It first looks in the
  17231      // current directory then the HDRS directory and finally it tries
  17301      // g/objline1 in the system root directory.
  17349      LET line1stream = findinput("objline1")
  17393      LET len = 0
  17409  
  17410      UNLESS line1stream DO
  17436        line1stream := pathfindinput("objline1", hdrs)
  17489      UNLESS line1stream IF rootnode!rtn_rootvar DO
  17539        line1stream := pathfindinput("g/objline1", rootnode!rtn_rootvar)
  17610      
  17615      IF line1stream DO
  17637      { // Copy first line of objline1 into string objline1
  17695        selectinput(line1stream)
  17726        WHILE len<255 DO
  17749        { LET ch = rdch()
  17773          IF ch='*n' | ch=endstreamch BREAK
  17815          len := len+1
  17836          objline1%len := ch
  17863        }
  17871        endread()
  17887        line1stream := 0
  17910      }
  17916      objline1%0 := len
  17938      objline1written := FALSE
  17967    }
  17971  
  17972    sourcestream := findinput(argv!0)       // FROM/A
  18024    sourcenamev!0 := argv!0    // File number zero is the FROM file
  18090    sourcefileno  := 0
  18111  
  18112    IF sourcestream=0 DO { writef("Trouble with file %s*n", argv!0)
  18178                           IF hard DO abort(1000)
  18226                           errcount := 1
  18265                           GOTO fin
  18299                         }
  18324  
  18325    selectinput(sourcestream)
  18353   
  18355    TEST argv!1                             // TO/K
  18405    THEN { // Change cin/ to cin64/ if necessary.
  18453           LET arg1 = argv!1
  18480           LET len  = arg1%0
  18500           LET tofilenamev = VEC 64+1 // Room for maximum length string.
  18571           tofilename := tofilenamev
  18606           FOR i = 0 TO len DO tofilename%i := arg1%i
  18651           IF t64 & len>4 &
  18677              arg1%1='c'  &
  18696              arg1%2='i'  &
  18715              arg1%3='n'  &
  18734              arg1%4='/'  DO
  18754           { // The target code is 64 bit and the destination starts
  18821             // with cin/ so replace it by cin64/
  18862             tofilename%4 := '6'
  18886             tofilename%5 := '4'
  18917             FOR i = 4 TO len DO tofilename%(i+2) := arg1%i
  18975             tofilename%0 := len+2
  19001           }
  19012  
  19013           writef("bcpl compiling to file: %s*n", tofilename)
  19073  
  19074           gostream := findoutput(tofilename)
  19118           IF gostream=0 DO
  19144           { writef("Trouble with code file %s*n", tofilename)
  19205             IF hard DO abort(1000)
  19239             errcount := 1
  19264             GOTO fin
  19284           }
  19295         }
  19304    ELSE { ocodeout := findoutput("ocode")
  19345           IF ocodeout=0 DO
  19371           { writes("Trouble with file ocode*n")
  19418             IF hard DO abort(1000)
  19452             errcount := 1
  19477             GOTO fin
  19497           }
  19508         }
  19517  
  19518    treevec := getvec(treesize)
  19548    obuf    := getvec(obufsize)
  19578  
  19579    IF treevec=0 | obuf=0 DO
  19606    { writes("Insufficient memory*n")
  19642      errcount := 1
  19660      GOTO fin
  19673    }
  19677     
  19681    IF argv!2 DO                            // VER/K
  19732    { TEST xrefing
  19749      THEN sysprint := findappend(argv!2)
  19789      ELSE sysprint := findoutput(argv!2)
  19829      IF sysprint=0 DO
  19850      { sysprint := stdout
  19875        writef("Trouble with file %s*n", argv!2)
  19922        IF hard DO abort(1000)
  19951        errcount := 1
  19971        GOTO fin
  19986      }
  19992    }
  19996  
  19997    selectoutput(sysprint)
  20022  
  20023    // Now syntax analyse, translate and code-generate each section
  20089    { LET b = VEC 64/bytesperword+1
  20123      chbuf := b
  20138      FOR i = 0 TO 63 DO chbuf%i := 0
  20174      // Sourcefile 0 is the FROM filename
  20215      // others are GET files of the current section
  20266      sourcenamev!0 := argv!0
  20294      sourcefileno := 0
  20316      FOR i = 1 TO sourcenamevupb DO sourcenamev!i := 0 // Done for safety
  20389      chcount, lineno := 0, (sourcefileno<<20) + 1
  20438      token, decval, fltval := 0, 0, flt0
  20478      rch()
  20488   
  20490      { // Start of loop to process each section
  20537        LET tree = ?
  20556        treep := treevec + treesize
  20590        mk3list := 0
  20609        obufp := 0
  20626        obuft := obufsize * bytesperword
  20665  
  20666        tree := formtree()
  20691        UNLESS tree BREAK
  20715  
  20716        //writef("Tree size %n*n", treesize+treevec-treep)
  20773   
  20775        IF prtree DO { writes("Parse Tree*n")
  20819                       plist(tree, 0, 20)
  20859                       newline()
  20890                     }
  20911    
  20914        IF errcount GOTO fin
  20941   
  20943        translate(tree)
  20965  
  20966        IF prtree2 DO { writes("*nParse Tree after calling translate*n")
  21037                        plist(tree, 0, 20)
  21078                        newline()
  21110                      }
  21132    
  21135        obufq := obufp     // Prepare to read from OCODE buffer
  21197        obufp := 0
  21214  
  21215        TEST argv!1=0  // TO/K
  21244        THEN { // Comment out one of the following lines
  21299               writeocode()  // Write OCODE file if no TO argument
  21364               //writeocodebytes()
  21397             }
  21410        ELSE codegenerate(treevec, treesize)
  21453      } REPEATWHILE token=s_dot
  21483    }
  21487     
  21491  fin:
  21496    IF getstreams    DO { LET p = getstreams
  21539                          getstreams := !p
  21580                          freevec(p)
  21615                        }
  21639    FOR i = 1 TO sourcefileno DO
  21670    { LET str = sourcenamev!i
  21698      IF str DO
  21712      { //sawritef("freeing fileno %n %s*n", i, str)
  21763        freevec(str)
  21782      }
  21788    }
  21792    IF sourcenamev   DO freevec(sourcenamev)
  21835  
  21836    IF treevec       DO freevec(treevec)
  21875    IF obuf          DO freevec(obuf)
  21911    IF sourcestream  DO IF sourcestream DO endstream(sourcestream)
  21976    IF ocodeout      IF ocodeout UNLESS ocodeout=stdout DO endstream(ocodeout)
  22053    IF gostream      IF gostream UNLESS gostream=stdout DO endstream(gostream)
  22130    UNLESS sysprint=stdout DO endstream(sysprint)
  22178  
  22179    selectoutput(stdout)
  22202    result2 := 0
  22217    RESULTIS errcount=0 -> 0, 20
  22248  }
  22250  
  22251  // ************* OCODE I/O Routines **************************
  22314  
  22315  /*
  22318  The OCODE buffer variables are:
  22350  
  22351  obuf         is the OCODE buffer -- (obuf=workvec)
  22402  obufp        position of next byte in the OCODE buffer
  22457  obufq        another pointer into the OCODE buffer
  22508  obuft        end of the OCODE buffer.
  22546  obufsize     size of obuf (in words)
  22583  */
  22586  
  22587  AND writeocode() BE
  22607  { LET layout = 0
  22624    selectoutput(ocodeout)
  22649  
  22650    UNTIL obufp>=obufq DO
  22674    { writef(" %n", rdn())
  22699      layout := layout+1
  22722      UNLESS layout MOD 16 DO newline()
  22760    }
  22764    newline()
  22776    selectoutput(sysprint)
  22801    writef("OCODE size: %i5/%n*n", obufq, obuft)
  22848  }
  22850  
  22851  AND rdn() = VALOF
  22869  { LET byte = obuf%obufp
  22893    IF obufp>=obufq RESULTIS 0
  22922    obufp := obufp+1
  22941    IF byte<223 RESULTIS byte
  22969    IF byte=223 RESULTIS -1
  22995    RESULTIS (byte&31) + (rdn()<<5)
  23029  }
  23031  
  23032  AND writeocodebytes() BE
  23057  { LET layout = 0
  23074    selectoutput(ocodeout)
  23099  
  23100    UNTIL obufp>=obufq DO
  23124    { writef(" => %n*n", rdnbytes())
  23159    }
  23163    newline()
  23175    selectoutput(sysprint)
  23200    writef("OCODE size: %i5/%n*n", obufq, obuft)
  23247  }
  23249  
  23250  AND rdnbytes() = VALOF
  23273  { LET byte = obuf%obufp
  23297    writef(" %i3", byte)
  23320    IF obufp>=obufq RESULTIS 0
  23349    obufp := obufp+1
  23368    IF byte<223 RESULTIS byte
  23396    IF byte=223 RESULTIS -1
  23422    RESULTIS (byte&31) + (rdnbytes()<<5)
  23461  }
  23463  
  23464  AND wrn(n) BE
  23478  { IF obufp>=obuft DO
  23499    { errmax := 0 // Make it fatal
  23532      trnerr("More workspace needed for OCODE buffer*n")
  23587    }
  23591    IF -1<=n<223 DO    // This is the normal case
  23639    { IF n=-1 DO n := 223
  23663      obuf%obufp := n
  23683      obufp := obufp + 1
  23706      RETURN
  23717    }
  23721    obuf%obufp := 224 + (n&31)
  23750    obufp := obufp + 1
  23771    // Perform an arithmetic right shift of 5 places
  23822    n := n & (~31)
  23839    n := n/32
  23851    //n := n>>5
  23865  } REPEAT
  23874  
  23875  // ************* End of  OCODE I/O Routines *******************
  23939  
  23940  LET calib(a) = a!10000 + a!-10000
  23974  // calib is provided to help check the calibration of
  24028  // graphs draw using rastsys and raster.
  24069  
  24070  LET lex() BE
  24083  { LET assop = ?
  24099    nlpending := FALSE
  24120    
  24123    //calib(1_000_000) 
  24145    //calib(treep)
  24162    
  24165    {
  24169  //sawritef("lex: ch=%i3 '%c'*n", ch, ch)
  24210   SWITCHON ch INTO
  24228   
  24230      { DEFAULT:
  24245                // The following gets around a
  24290                // bug on the Itanium
  24326                IF ch=endstreamch GOTO endstr
  24370  
  24371              { LET badch = ch
  24400                ch := '*s'
  24425                synerr("Illegal character %x2", badch)
  24478              }
  24492  
  24493        CASE '*n':  // Newline character
  24532                 lineno := lineno + 1
  24568                 nlpending := TRUE  // IGNORABLE CHARACTERS
  24626        CASE '*p':  // Newpage character - do not increment lineno
  24691        CASE '*c':
  24708        CASE '*t':
  24725        CASE '*s':
  24742                 rch() REPEATWHILE ch='*s'
  24783                 LOOP
  24803  
  24804        CASE '0':CASE '1':CASE '2':CASE '3':CASE '4':
  24856        CASE '5':CASE '6':CASE '7':CASE '8':CASE '9':
  24908                readdecimal()
  24936                // token is either s_number with decval set
  24994                // or s_fnum with fltval set.
  25038                RETURN
  25059   
  25061        CASE 'a':CASE 'b':CASE 'c':CASE 'd':CASE 'e':
  25113        CASE 'f':CASE 'g':CASE 'h':CASE 'i':CASE 'j':
  25165        CASE 'k':CASE 'l':CASE 'm':CASE 'n':CASE 'o':
  25217        CASE 'p':CASE 'q':CASE 'r':CASE 's':CASE 't':
  25269        CASE 'u':CASE 'v':CASE 'w':CASE 'x':CASE 'y':
  25321        CASE 'z':
  25337        CASE 'A':CASE 'B':CASE 'C':CASE 'D':CASE 'E':
  25389        CASE 'F':CASE 'G':CASE 'H':CASE 'I':CASE 'J':
  25441        CASE 'K':CASE 'L':CASE 'M':CASE 'N':CASE 'O':
  25493        CASE 'P':CASE 'Q':CASE 'R':CASE 'S':CASE 'T':
  25545        CASE 'U':CASE 'V':CASE 'W':CASE 'X':CASE 'Y':
  25597        CASE 'Z':
  25613                token := lookupword(rdtag(ch))
  25658                SWITCHON token INTO
  25692                { DEFAULT: RETURN
  25724  
  25725                  CASE s_get:  performget(); LOOP
  25773  
  25774                  CASE s_bitsperbcplword:
  25814                     token := s_number
  25851                     decval := wordbitlen // Target code word length
  25918                     RETURN
  25944  
  25945                  // Some reserved words become assignment operators
  26012                  // if followed by :=
  26049  
  26050                  CASE s_mod:    assop := s_assmod;    GOTO checkass
  26117                  ///CASE s_lshift: assop := s_asslshift; GOTO checkass
  26187                  ///CASE s_rshift: assop := s_assrshift; GOTO checkass
  26257                  ///CASE s_logand: assop := s_asslogand; GOTO checkass
  26327                  ///CASE s_logor:  assop := s_asslogor;  GOTO checkass
  26397                  CASE s_eqv:    assop := s_asseqv;    GOTO checkass
  26464                  CASE s_xor:    assop := s_assxor;    GOTO checkass
  26531                }
  26547  
  26548   
  26550        CASE '$':
  26566                rch()
  26586                IF ch='$' | ch='<' | ch='>' | ch='~' DO
  26640                { LET k = ch
  26667  //sawritef("*nprocessing $%c*n", ch)
  26704                  token := lookupword(rdtag('<'))
  26752  //sawritef("charv=%s token=%n*n", charv, token)
  26800                  // token = s_true             if the tag is set
  26864                  //       = s_false or s_name  otherwise
  26920   
  26922                  // $>tag   marks the end of a conditional
  26980                  //         skipping section
  27024                  IF k='>' DO
  27052                  { IF skiptag=wordnode DO
  27093                      skiptag := 0   // Matching $>tag found
  27152                    LOOP
  27175                  }
  27193   
  27195                  IF skiptag LOOP
  27227  
  27228                  // Only process $<tag and $$tag if not skipping
  27292   
  27294                  IF k='$' DO
  27322                  { // $$tag  complements the value of a tag
  27381                    h1!wordnode := token=s_true -> s_false, s_true
  27446                    LOOP
  27469                  }
  27487   
  27489                  IF k='<' DO
  27517                  { // $<tag
  27544                    IF token=s_true LOOP // Option set so don't skip
  27611                  }
  27629  
  27630                  IF k='~' DO
  27658                  { // $~tag
  27685                    UNLESS token=s_true LOOP // Option not set so don't skip
  27760                  }
  27778  
  27779                  // Skip tokens until matching $>tag, EOF or end of section
  27854                  skiptag := wordnode
  27890                  UNTIL skiptag=0 | token=s_dot | token=s_eof DO lex()
  27959                  skiptag := 0
  27988                  RETURN
  28011                }
  28027   
  28029                UNLESS ch='(' | ch=')' DO synerr("'$' out of context")
  28098                token := ch='(' -> s_lsect, s_rsect
  28148                lookupword(rdtag('$'))
  28185                RETURN
  28206   
  28208        CASE '{': token, wordnode := s_lsect, nulltag; BREAK
  28267        CASE '}': token, wordnode := s_rsect, nulltag; BREAK
  28326  
  28327        CASE '#':
  28343                token := s_number
  28375                rch()
  28395                IF '0'<=ch<='7' DO
  28428                { decval := readnumber( 8, 100)
  28474                  RETURN
  28497                }
  28513                IF ch='b' | ch='B' DO
  28549                { rch()
  28571                  decval := readnumber( 2, 100)
  28617                  RETURN
  28640                }
  28656                IF ch='o' | ch='O' DO
  28692                { rch()
  28714                  decval := readnumber( 8, 100)
  28760                  RETURN
  28783                }
  28799                IF ch='x' | ch='X' DO
  28835                { rch()
  28857                  decval := readnumber(16, 100)
  28903                  RETURN
  28926                }
  28942                IF ch='(' DO
  28969                { token := s_mthap
  29002                  RETURN
  29025                }
  29041                UNLESS ch<32 DO
  29071                { // Get the next token
  29109                  lex()
  29131                  SWITCHON token INTO
  29167                  { DEFAULT:       ENDCASE
  29208  
  29209                    CASE s_abs:    token := s_fabs;    RETURN
  29269  
  29270                    CASE s_mul :   token := s_fmul;    RETURN
  29330                    CASE s_div:    token := s_fdiv;    RETURN
  29390                    CASE s_mod:    token := s_fmod;    RETURN
  29450                    CASE s_add:    token := s_fadd;    RETURN
  29510                    CASE s_sub:    token := s_fsub;    RETURN
  29570  
  29571                    CASE s_ass:    token := s_fass;    RETURN
  29631                    CASE s_assmul: token := s_assfmul; RETURN
  29691                    CASE s_assdiv: token := s_assfdiv; RETURN
  29751                    CASE s_assmod: token := s_assfmod; RETURN
  29811                    CASE s_assadd: token := s_assfadd; RETURN
  29871                    CASE s_asssub: token := s_assfsub; RETURN
  29931  
  29932                    CASE s_eq:     token := s_feq;     RETURN
  29992                    CASE s_ne:     token := s_fne;     RETURN
  30052                    CASE s_ls:     token := s_fls;     RETURN
  30112                    CASE s_le:     token := s_fle;     RETURN
  30172                    CASE s_gr:     token := s_fgr;     RETURN
  30232                    CASE s_ge:     token := s_fge;     RETURN
  30292  
  30293                    CASE s_cond:   token := s_fcond;   RETURN
  30353                  }
  30371                }
  30387                synerr("'#' out of context")
  30430  
  30431        CASE '[': token := s_sbra;      BREAK
  30475        CASE ']': token := s_sket;      BREAK
  30519        CASE '(': token := s_lparen;    BREAK
  30563        CASE ')': token := s_rparen;    BREAK 
  30608        CASE '?': token := s_query;     BREAK
  30652        CASE ',': token := s_comma;     BREAK
  30696        CASE ';': token := s_semicolon; BREAK
  30740        CASE '@': token := s_lv;        BREAK
  30784        CASE '=': token := s_eq;        BREAK
  30828        CASE '%': token := s_byteap;    BREAK
  30872  
  30873        CASE '.': token := s_dot
  30904                  rch()
  30926                  UNLESS getstreams RETURN
  30967                  synerr("A section separating dot is not allowed in GET files")
  31032                  LOOP
  31039  
  31040  checkassx:      rch()
  31062  checkass:       UNLESS ch=':' RETURN
  31099                  rch()
  31121                  UNLESS ch='=' DO synerr("Bad assignment operator")
  31188                  token := assop
  31219                  BREAK
  31241   
  31243        CASE '!': token, assop := s_vecap, s_assvecap;   GOTO checkassx
  31313        CASE '**':token, assop := s_mul, s_assmul;       GOTO checkassx
  31383        CASE '+': token, assop := s_add, s_assadd;       GOTO checkassx
  31453        CASE '&': token, assop := s_logand, s_asslogand; GOTO checkassx
  31523        CASE '|': token, assop := s_logor, s_asslogor;   GOTO checkassx
  31593   
  31595        CASE '/':
  31611                rch()
  31631                //IF ch='\' DO    // Disallow /\ for &
  31684                //{ token, assop := s_logand, s_asslogand
  31740                //  GOTO checkassx
  31773                //}
  31791                IF ch='/' DO
  31818                { rch() REPEATUNTIL ch='*n' |
  31862                                    //ch='*p' | // Do not increment lineno
  31935                                    ch=endstreamch
  31984                  LOOP
  32005                }
  32021   
  32023                IF ch='**' DO
  32051                { LET depth = 1
  32081  
  32082                  { rch()
  32106                    IF ch='**' DO
  32138                    { rch() REPEATWHILE ch='**'
  32184                      IF ch='/' DO { depth := depth-1; LOOP }
  32244                    }
  32264                    IF ch='/' DO
  32295                    { rch()
  32321                      IF ch='**' DO { depth := depth+1; LOOP }
  32382                    }
  32402                    IF ch='*n' DO lineno := lineno+1
  32453                    IF ch=endstreamch DO synerr("Missing '**/'")
  32516                  } REPEATUNTIL depth=0
  32554  
  32555                  rch()
  32577                  LOOP
  32598                }
  32614  
  32615                token, assop := s_div, s_assdiv
  32661                GOTO checkass
  32689   
  32691        CASE '~':
  32707                rch()
  32727                IF ch='=' DO { token := s_ne;     BREAK }
  32783                token := s_not
  32812                RETURN
  32833   
  32835        CASE '\':
  32851                rch()
  32871                //IF ch='/' DO    // Disallow \/ for |
  32924                //{ token, assop := s_logor, s_asslogor
  32978                //  GOTO checkassx
  33011                //}
  33029                IF ch='=' DO { token := s_ne;     BREAK }
  33085                token := s_not
  33114                RETURN
  33135   
  33137        CASE '<': rch()
  33159                IF ch='=' DO { token := s_le;     BREAK }
  33215                IF ch='<' DO
  33242                { token, assop := s_lshift, s_asslshift
  33296                  GOTO checkassx
  33327                }
  33343                IF ch='>' DO { token := s_seq;    BREAK }
  33399                token := s_ls
  33427                RETURN
  33448   
  33450        CASE '>': rch()
  33472                IF ch='=' DO { token := s_ge;     BREAK }
  33528                IF ch='>' DO
  33555                { token, assop := s_rshift, s_assrshift
  33609                  GOTO checkassx
  33640                }
  33656                token := s_gr
  33684                RETURN
  33705   
  33707        CASE '-': rch()
  33729                IF ch='>' DO { token := s_cond; BREAK  }
  33784                token, assop := s_sub, s_asssub
  33830                GOTO checkass
  33858   
  33860        CASE ':': rch()
  33882                IF ch='=' DO { token := s_ass; BREAK  }
  33936                IF ch=':' DO { token := s_of;  BREAK  }  // Inserted 11/7/01
  34011                token := s_colon
  34042                RETURN
  34063   
  34065        CASE '"':
  34081             { LET len = 0
  34106               rch()
  34125               encoding := defaultencoding // encoding for *# escapes
  34193  
  34194               UNTIL ch='"' DO
  34223               { LET code = rdstrch()
  34259                 TEST result2
  34287                 THEN { // A  *# code found.
  34330                        // Convert it to UTF8 or GB2312 format.
  34392                        TEST encoding=GB2312
  34435                        THEN { // Convert to GB2312 sequence
  34494                               IF code>#x7F DO
  34539                               { LET hi = code  /  100 + 160
  34598                                 LET lo = code MOD 100 + 160
  34657                                 IF len>=254 DO synerr("Bad string constant")
  34733                                 TEST bigender
  34778                                 THEN { charv%(len+1) := hi 
  34837                                        charv%(len+2) := lo
  34895                                      }
  34933                                 ELSE { charv%(len+1) := lo 
  34992                                        charv%(len+2) := hi
  35050                                      }
  35088                                 len := len + 2
  35134                                 LOOP
  35170                               }
  35201                               IF len>=255 DO synerr("Bad string constant")
  35275                               charv%(len+1) := code // Ordinary ASCII char
  35349                               len := len + 1
  35393                               LOOP
  35427                             }
  35456                        ELSE { // Convert to UTF8 sequence
  35513                               IF code<=#x7F DO
  35559                               { IF len>=255 DO synerr("Bad string constant")
  35635                                 charv%(len+1) := code   // 0xxxxxxx
  35702                                 len := len + 1
  35748                                 LOOP
  35784                               }
  35815                               IF code<=#x7FF DO
  35862                               { IF len>=254 DO synerr("Bad string constant")
  35938                                 charv%(len+1) := #b1100_0000+(code>>6)  // 110xxxxx
  36021                                 charv%(len+2) := #x80+( code    &#x3F)  // 10xxxxxx
  36104                                 len := len + 2
  36150                                 LOOP
  36186                               }
  36217                               IF code<=#xFFFF DO
  36265                               { IF len>=253 DO synerr("Bad string constant")
  36341                                 charv%(len+1) := #b1110_0000+(code>>12) // 1110xxxx
  36424                                 charv%(len+2) := #x80+((code>>6)&#x3F)  // 10xxxxxx
  36507                                 charv%(len+3) := #x80+( code    &#x3F)  // 10xxxxxx
  36590                                 len := len + 3
  36636                                 LOOP
  36672                               }
  36703                               IF code<=#x1F_FFFF DO
  36754                               { IF len>=252 DO synerr("Bad string constant")
  36830                                 charv%(len+1) := #b1111_0000+(code>>18) // 11110xxx
  36913                                 charv%(len+2) := #x80+((code>>12)&#x3F) // 10xxxxxx
  36996                                 charv%(len+3) := #x80+((code>> 6)&#x3F) // 10xxxxxx
  37079                                 charv%(len+4) := #x80+( code     &#x3F) // 10xxxxxx
  37162                                 len := len + 4
  37208                                 LOOP
  37244                               }
  37275                               IF code<=#x3FF_FFFF DO
  37327                               { IF len>=251 DO synerr("Bad string constant")
  37403                                 charv%(len+1) := #b1111_1000+(code>>24) // 111110xx
  37486                                 charv%(len+2) := #x80+((code>>18)&#x3F) // 10xxxxxx
  37569                                 charv%(len+3) := #x80+((code>>12)&#x3F) // 10xxxxxx
  37652                                 charv%(len+4) := #x80+((code>> 6)&#x3F) // 10xxxxxx
  37735                                 charv%(len+5) := #x80+( code     &#x3F) // 10xxxxxx
  37818                                 len := len + 5
  37864                                 LOOP
  37900                               }
  37931                               IF code<=#x7FFF_FFFF DO
  37984                               { IF len>=250 DO synerr("Bad string constant")
  38060                                 charv%(len+1) := #b1111_1100+(code>>30) // 1111110x
  38143                                 charv%(len+2) := #x80+((code>>24)&#x3F) // 10xxxxxx
  38226                                 charv%(len+3) := #x80+((code>>18)&#x3F) // 10xxxxxx
  38309                                 charv%(len+4) := #x80+((code>>12)&#x3F) // 10xxxxxx
  38392                                 charv%(len+5) := #x80+((code>> 6)&#x3F) // 10xxxxxx
  38475                                 charv%(len+6) := #x80+( code     &#x3F) // 10xxxxxx
  38558                                 len := len + 6
  38604                                 LOOP
  38640                               }
  38671                               synerr("Bad Unicode character")
  38732                             }
  38761                      }
  38783                 ELSE { // Not a Unicode character
  38832                        IF len=255 DO synerr("Bad string constant")
  38898                        len := len + 1
  38935                        charv%len := code
  38975                      }
  38997               }
  39012   
  39014               charv%0 := len
  39042               wordnode := newvec(len/bytesperword+2)
  39094               h1!wordnode := s_string
  39131               FOR i = 0 TO len DO (@h2!wordnode)%i := charv%i
  39192               token := s_string
  39223               BREAK
  39242            }
  39254   
  39256        CASE '*'':
  39273                rch()
  39293                encoding := defaultencoding
  39335                decval := rdstrch()
  39369                token := s_number
  39401                UNLESS ch='*'' DO synerr("Bad character constant")
  39466                BREAK
  39486   
  39488   endstr:
  39497        //CASE endstreamch: // Commented out because of an Itanium bug
  39566                IF getstreams DO
  39597                { // Return from a 'GET' stream
  39643                  LET p = getstreams
  39678                  endread()
  39704                  ch           := h4!getstreams
  39750                  lineno       := h3!getstreams
  39796                  sourcestream := h2!getstreams
  39842                  getstreams   := h1!getstreams
  39888                  freevec(p) // Free the GET node
  39936                  selectinput(sourcestream)
  39978                  LOOP
  39999                }
  40015                // endstreamch => EOF only at outermost GET level 
  40080                token := s_eof
  40109                RETURN
  40130      }
  40136    } REPEAT
  40147   
  40149    rch()
  40157  }
  40159   
  40161  LET lookupword(word) = VALOF
  40190  { LET len, i = word%0, 0
  40215    LET hashval = 19609 // This and 31397 are primes.
  40267    FOR j = 0 TO len DO hashval := (hashval XOR word%j) * 31397
  40329    hashval := (hashval>>1) MOD nametablesize
  40373  
  40374    wordnode := nametable!hashval
  40406   
  40408    UNTIL wordnode=0 | i>len TEST (@h3!wordnode)%i=word%i
  40464                             THEN i := i+1
  40505                             ELSE wordnode, i := h2!wordnode, 0
  40567   
  40569    UNLESS wordnode DO
  40590    { wordnode := newvec(len/bytesperword+2)
  40633      h1!wordnode, h2!wordnode := s_name, nametable!hashval
  40691      FOR i = 0 TO len DO (@h3!wordnode)%i := word%i
  40742      nametable!hashval := wordnode
  40776    }
  40780   
  40782    RESULTIS h1!wordnode
  40805  }
  40807   
  40809  LET eqlookupword(word) = VALOF
  40840  { // This version equates the cases but keeps the cases of
  40899    // the first word encountered. If EQCASES is given this version
  40965    // replaces lookupword.
  40991    LET len, i = word%0, 0
  41016    LET hashval = 19609 // This and 31397 are primes.
  41068    // This hash function ignores the case of letters.
  41121    FOR j = 0 TO len DO hashval := (hashval XOR (word%j & 31)) * 31397
  41190    hashval := (hashval>>1) MOD nametablesize
  41234  
  41235    wordnode := nametable!hashval
  41267   
  41269    UNTIL wordnode=0 | i>len TEST compch((@h3!wordnode)%i, word%i)=0
  41336                             THEN i := i+1
  41377                             ELSE wordnode, i := h2!wordnode, 0
  41439   
  41441    UNLESS wordnode DO
  41462    { wordnode := newvec(len/bytesperword+2)
  41505      h1!wordnode, h2!wordnode := s_name, nametable!hashval
  41563      FOR i = 0 TO len DO (@h3!wordnode)%i := word%i
  41614      nametable!hashval := wordnode
  41648    }
  41652   
  41654    RESULTIS h1!wordnode
  41677  }
  41679   
  41681  AND dsw(word, sym) BE { lookupword(word); h1!wordnode := sym  }
  41745   
  41747  AND declsyswords() BE
  41769  { dsw("AND", s_and)  // Added old 1980s style reserved word for historic reasons.
  41851    dsw("ABS", s_abs)
  41871    dsw("BE", s_be)
  41889    dsw("BITSPERBCPLWORD", s_bitsperbcplword)
  41933    dsw("BREAK", s_break)
  41957    dsw("BY", s_by)
  41975    dsw("CASE", s_case)
  41997    dsw("DO", s_do)
  42015    dsw("DEFAULT", s_default)
  42043    dsw("EQ", s_eq)
  42061    dsw("EQV", s_eqv)
  42081    dsw("ELSE", s_else)
  42103    dsw("ENDCASE", s_endcase)
  42131    dsw("FALSE", s_false)
  42155    dsw("FINISH", s_finish)
  42181    dsw("FIX", s_fix)
  42201    dsw("FLOAT", s_float)
  42225    dsw("FLT", s_flt)
  42245    dsw("FOR", s_for)
  42265    dsw("GOTO", s_goto)
  42287    dsw("GE", s_ge)
  42305    dsw("GR", s_gr)
  42323    dsw("GLOBAL", s_global)
  42349    dsw("GET", s_get)
  42369    dsw("IF", s_if)
  42387    dsw("INTO", s_into)
  42409    dsw("LET", s_let)
  42429    dsw("LV", s_lv)
  42447    dsw("LE", s_le)
  42465    dsw("LS", s_ls)
  42483    dsw("LOGOR", s_logor)
  42507    dsw("LOGAND", s_logand)
  42533    dsw("LOOP", s_loop)
  42555    dsw("LSHIFT", s_lshift)
  42581    dsw("MANIFEST", s_manifest)
  42611    dsw("MOD", s_mod)
  42631    dsw("NE", s_ne)
  42649    dsw("NEEDS", s_needs)
  42673    dsw("NEQV", s_xor)
  42694    dsw("NOT", s_not)
  42714    dsw("OF", s_of)                   // Inserted 11/7/01
  42770    dsw("OR", s_else)
  42790    dsw("RESULTIS", s_resultis)
  42820    dsw("RETURN", s_return)
  42846    dsw("REM", s_mod)
  42866    dsw("RSHIFT", s_rshift)
  42892    dsw("RV", s_rv)
  42910    dsw("REPEAT", s_repeat)
  42936    dsw("REPEATWHILE", s_repeatwhile)
  42972    dsw("REPEATUNTIL", s_repeatuntil)
  43008    dsw("SECTION", s_section)
  43036    dsw("SLCT", s_slct)               // Inserted 11/7/01
  43092    dsw("STATIC", s_static)
  43118    dsw("SWITCHON", s_switchon)
  43148    dsw("TO", s_to)
  43166    dsw("TEST", s_test)
  43188    dsw("TRUE", s_true)
  43210    dsw("THEN", s_do)
  43230    dsw("TABLE", s_table)
  43254    dsw("UNLESS", s_unless)
  43280    dsw("UNTIL", s_until)
  43304    dsw("VEC", s_vec)
  43324    dsw("VALOF", s_valof)
  43348    dsw("WHILE", s_while)
  43372    dsw("XOR", s_xor)
  43392    dsw("$", 0)
  43406   
  43408    nulltag := wordnode
  43430  } 
  43433   
  43435  LET rch() BE
  43448  { ch := rdch()
  43463    chcount := chcount + 1
  43488    chbuf%(chcount&63) := ch
  43515  }
  43517   
  43519  AND wrchbuf() BE
  43536  { writes("*n...")
  43554    FOR p = chcount-63 TO chcount DO
  43589    { LET k = chbuf%(p&63)
  43614      IF 0<k<255 DO wrch(k)
  43640    }
  43644    newline()
  43656  }
  43658   
  43660   
  43662  AND rdoptstring() = VALOF
  43688  { LET pos = 1 // The position of the next optstring
  43740                // character to consider
  43779    LET optstringlen = optstring%0
  43812    LET optch = ?
  43828  
  43829    { // Get next option name, if any
  43865      LET len = 1
  43881      charv%0, charv%1 := 1, '<'
  43912   
  43914      // Skip characters before option name
  43956      WHILE pos<=optstringlen DO
  43987      { optch := optstring%pos
  44016        IF 'a'<=optch<='z' | 'A'<=optch<='Z' |
  44061           '0'<=optch<='9' | optch='.' | optch='_' BREAK
  44116        pos := pos+1
  44135      }
  44141  
  44142      // Copy option name, if any, into charv
  44186      WHILE pos<=optstringlen DO
  44217      { optch := optstring%pos
  44246        UNLESS 'a'<=optch<='z' | 'A'<=optch<='Z' |
  44295               '0'<=optch<='9' | optch='.' | optch='_' BREAK
  44354        // Copy next option name character into charv, if room
  44415        len := len+1
  44434        IF len<=255 DO charv%0, charv%len := len, optch
  44488        pos := pos+1
  44507      }
  44513  
  44514      IF len<=1 BREAK // No more option names
  44558  
  44559      // Declare option name
  44586      token := lookupword(charv)
  44617      h1!wordnode := s_true
  44643  
  44644  //sawritef("Option name: ", wordnode, h1!wordnode)
  44695  //FOR i = 2 TO charv%0 DO sawrch(charv%i)
  44737  //sawritef(" declared*n")
  44763  
  44764    } REPEAT    // Read next option name, if any
  44811  }
  44813  
  44814  AND rdtag(ch1) = VALOF
  44837  { LET len = 1
  44851    ///IF eqcases & 'a'<=ch1<='z' DO ch1 := ch1 + 'A' - 'a'
  44909    charv%1 := ch1
  44926   
  44928    { rch()
  44938      UNLESS 'a'<=ch<='z' | 'A'<=ch<='Z' |
  44979             '0'<=ch<='9' | ch='.' | ch='_' BREAK
  45027      ///IF eqcases & 'a'<=ch<='z' DO ch := ch + 'A' - 'a'
  45084      len := len+1
  45101      charv%len := ch
  45121    } REPEAT
  45132   
  45134    charv%0 := len
  45151    RESULTIS charv
  45168  }
  45170  
  45171  AND catstr(s1, s2) = VALOF
  45198  // Concatenate strings s1 and s2 leaving the result in s1.
  45257  // s1 is assumed to be able to hold a string of length 255.
  45317  // The resulting string is truncated to length 255, if necessary. 
  45384  { LET len = s1%0
  45401    LET n = len
  45415    FOR i = 1 TO s2%0 DO
  45438    { n := n+1
  45451      IF n>255 BREAK
  45470      s1%n := s2%i
  45487    }
  45491    s1%0 := n
  45503  } 
  45506   
  45508  AND performget() BE
  45528  { LET stream = ?
  45545    LET len = 0
  45559    lex()
  45567    UNLESS token=s_string DO synerr("Bad GET directive")
  45622    len := charv%0
  45639  
  45640    // Append .h to the GET filename does not end in .h or .b
  45700    UNLESS len>=2 & charv%(len-1)='.' & 
  45739           (charv%len='h' | charv%len='b') DO
  45783    { len := len+2
  45800      charv%0, charv%(len-1), charv%len := len, '.', 'h'
  45855    }
  45859  
  45860    // Treat filenames like sys:xxx as sys/xxx -- deprecated feature 
  45928    FOR i = 1 TO charv%0 IF charv%i=':' DO charv%i := '/'
  45984  
  45985    // First look in the current directory
  46026    //writef("Searching for *"%s*" in the current directory*n", charv)
  46095    stream := pathfindinput(charv, 0)
  46131  
  46132  
  46133    // Then try the headers directories
  46171    //UNLESS stream DO sawritef("Searching for *"%s*" in %s*n", charv, hdrs)
  46246    // The value of hdrs is typically: ...../BCPL/cintcode/g
  46305    UNLESS stream DO stream := pathfindinput(charv, hdrs)
  46361  
  46362    UNLESS stream DO
  46381    { synerr("Unable to find GET file %s", charv)
  46429      RETURN
  46440    }
  46444  
  46445    IF sourcefileno>=sourcenamevupb DO
  46482    { synerr("Too many GET files")
  46515      RETURN
  46526    }
  46530  
  46531    { LET len  = charv%0
  46554      LET node = getvec(3)  // Freed at end of GET insertion
  46613      LET str  = getvec(len/bytesperword+1) // Freed at end of compilation
  46686  
  46687      UNLESS node & str DO
  46712      { IF node DO freevec(node)
  46743        IF str  DO freevec(str)
  46773        synerr("getvec failure in performget")
  46818      }
  46824      FOR i = 0 TO len DO str%i := charv%i
  46865      sourcefileno := sourcefileno+1
  46900      sourcenamev!sourcefileno := str
  46936  
  46937      node!0, node!1, node!2, node!3 := getstreams, sourcestream, lineno, ch
  47012      getstreams := node
  47035    }
  47039    sourcestream := stream
  47064    selectinput(sourcestream)
  47092    lineno := (sourcefileno<<20) + 1
  47127    rch()
  47135  }
  47137  
  47138  AND readdecimal() BE
  47159  { // Read an integer or floating point constant
  47207    // setting token to s_number with the integer value in decval
  47271    // or s_fnum with the floating point value in fltval.
  47327    // The strategy is to simultaneously construct both the integer
  47393    // and floating point values. It stop constructing the integer
  47458    // value after reading a decimal point or e, ie when the
  47517    // constant is known to be floating point.
  47562    LET pos      = 0    // Number of integer and fractional digits
  47627                        // in the number.
  47667    LET sigpos   = 0    // Position of the last significant digit
  47731    LET pointpos = 0    // Position of the digit just left of the
  47795                        // decimal point
  47834  
  47835    token := s_number // Until '.' or 'e' encountered
  47887    decval, exponent, fltval := 0, 0, flt0
  47928  
  47929    // A number must start with a digit.
  47968    UNLESS '0'<=ch<='9' DO synerr("Bad number")
  48014  
  48015    WHILE '0'<=ch<='9' | ch='_' | ch='.' DO
  48057    { // Deal with digits before e, if any.
  48099      //writef("ch=%c pos=%n token=%n decval=%i4 exponent=%n*n",
  48162      //        ch, pos, token, decval, exponent)
  48210      SWITCHON ch INTO
  48231      { DEFAULT: BREAK // ch is either e, E or terminates the number.
  48299  
  48300        CASE '0': CASE '1': CASE '2': CASE '3': CASE '4': 
  48357        CASE '5': CASE '6': CASE '7': CASE '8': CASE '9':
  48413        { LET x = sys(Sys_flt, fl_mul, fltval, flt10)  // = 10 * fltval
  48483          pos := pos+1                 // Increment count of digits
  48549          IF token=s_number DO pointpos := pos
  48594  
  48595          decval := 10*decval + ch-'0' // Accumulate the integer value
  48664  
  48665          IF sys(Sys_flt, fl_eq, x, sys(Sys_flt, fl_add, x, flt1)) ENDCASE
  48738  
  48739          // fltval * 10 + 1 is not equal to fltval * 10, so
  48798          // the digit is significant
  48834          // Perform fltval := x + FLOAT(ch-'0') and increment sigpos .
  48904          fltval := sys(Sys_flt,
  48935                        fl_add, x, sys(Sys_flt, fl_float, ch-'0'))
  49000          sigpos := sigpos+1
  49027          ENDCASE
  49043        }
  49051  
  49052        CASE '.': 
  49069          IF token=s_fnum DO synerr("Bad floating point constant")
  49134          token := s_fnum
  49158          ENDCASE
  49174  
  49175        CASE '_':  // Ignore underlines in numbers.
  49225          ENDCASE
  49241      }
  49247      rch()
  49257    }
  49261  
  49262  //sawritef("readdecimal: token=%s decval=%n fltval=%13.1e pos=%n sigpos=%n pointpos=%n*n",
  49353  //          opname(token), decval, fltval, pos, sigpos, pointpos)
  49419  
  49420    IF ch='e' | ch='E' DO
  49444    { LET expneg = FALSE
  49467      token := s_fnum
  49487      rch()
  49497      IF ch='-' DO { expneg := TRUE; rch() }
  49540      WHILE '0'<=ch<='9' | ch='_' DO
  49575      { UNLESS ch='_' DO exponent := 10*exponent + ch-'0'
  49631        rch()
  49643      }
  49649      IF expneg DO exponent := -exponent
  49688    }
  49692  
  49693    IF token=s_number DO
  49716    { // There was no decimal point or e so leave token=s_number
  49779      // and the integer value in decval.
  49819      RETURN
  49830    }
  49834  
  49835    // token is s_fnum
  49856  
  49857  //sawritef("*nreaddecimal: making fnumber fltval=%13.1e exponent=%n sigpos=%n, pointpos=%n*n",
  49952  //          fltval, exponent, sigpos, pointpos)
  50000    // Correct the exponent
  50026    exponent := exponent + pointpos - sigpos
  50069  
  50070    UNLESS -127 <= exponent <= 127 DO
  50106      synerr("Floating point exponent out of range")
  50157  
  50158    // Set fltval to fltval x 10^exponent
  50198    TEST exponent>=0
  50217    THEN FOR i = 1 TO exponent DO
  50249           fltval := sys(Sys_flt, fl_mul, fltval, flt10)
  50304    ELSE FOR i = -1 TO exponent BY -1 DO
  50343           fltval := sys(Sys_flt, fl_div, fltval, flt10)
  50398  //sawritef("*n=> fltval=%13e*n", fltval)
  50439  
  50440    // fltval is a floating point number of the same size as
  50499    // the BCPL word length.
  50526  }
  50528  
  50529  AND readnumber(radix, digs) = VALOF
  50565  // Read a binary, octal, decimal or hexadecimal unsigned number
  50629  // with between 1 and digs digits. Underlines are allowed.
  50688  // This function is only used for numerical constants starting
  50751  // with # or numerical escapes in string and character constants.
  50817  { LET i, res = 0, 0
  50837   
  50839    { UNLESS ch='_' DO // ignore underlines
  50881      { LET d = value(ch)
  50905        IF d>=radix BREAK
  50929        i := i+1       // Increment count of digits
  50979        res := radix*res + d
  51006      }
  51012      rch()
  51022    } REPEATWHILE i<digs
  51045  
  51046    UNLESS i DO synerr("Bad number")
  51081    RESULTIS res
  51096  }
  51098   
  51100   
  51102  AND value(ch) = '0'<=ch<='9' -> ch-'0',
  51142                  'A'<=ch<='F' -> ch-'A'+10,
  51185                  'a'<=ch<='f' -> ch-'a'+10,
  51228                  100
  51248   
  51250  AND rdstrch() = VALOF
  51272  { // Return the integer code for the next string character
  51331    // Set result2=TRUE if *# character code was found, otherwise FALSE
  51401    LET k = ch
  51414  
  51415    IF k='*n' DO
  51430    { lineno := lineno+1
  51453      synerr("Unescaped newline character")
  51495    }
  51499   
  51501    IF k='**' DO
  51516    { rch()
  51526      k := ch
  51538      IF 'a'<=k<='z' DO k := k + 'A' - 'a'
  51579      SWITCHON k INTO
  51599      { CASE '*n':
  51616        CASE '*c':
  51633        CASE '*p':
  51650        CASE '*s':
  51667        CASE '*t':
  51684        CASE  '/': // Ignore white space until the next asterisk.
  51748                   // Comments starting with '//' are treated as
  51811                   // white space, but those starting with '/*'
  51873                   // are not.
  51902                   { WHILE ch='*n' | ch='*c' | ch='*p' | ch='*s' | ch='*t' DO
  51978                     { IF //ch='*p' |  // Do not increment lineno
  52042                          ch='*n' DO lineno := lineno+1
  52096                       rch()
  52123                     }
  52144                     IF ch='/' DO
  52176                     { rch()
  52203                       IF ch='/' DO
  52237                       { // Skip over a '//' comment
  52288                         rch() REPEATUNTIL ch='*n' |
  52339                                           ch='*p' |
  52390                                           ch=endstreamch
  52446                         LOOP
  52474                       }
  52497                     }
  52518                     BREAK
  52543                   } REPEAT
  52569                   IF ch='**' DO { rch(); LOOP  }
  52617  
  52618        DEFAULT:   synerr("Bad string or character constant, ch=%n", ch)
  52689           
  52699        CASE '**':
  52716        CASE '*'':
  52733        CASE '"':                    ENDCASE
  52776           
  52786        CASE 'T':  k := c_tab;       ENDCASE
  52829        CASE 'S':  k := c_space;     ENDCASE
  52872        CASE 'N':  k := c_newline;   ENDCASE
  52915        CASE 'E':  k := c_escape;    ENDCASE
  52958        CASE 'B':  k := c_backspace; ENDCASE
  53001        CASE 'P':  k := c_newpage;   ENDCASE
  53044        CASE 'C':  k := c_return;    ENDCASE
  53087           
  53097        CASE 'X':  // *xhh  -- A character escape in hexadecimal
  53160                   rch()
  53183                   k := readnumber(16,2)
  53222                   result2 := FALSE
  53256                   RESULTIS k
  53284  
  53285        CASE '#':  // *#u   set UTF8 mode
  53325                   // *#g   set GB2312 mode
  53367                   // In UTF8 mode
  53400                   //     *#hhhh or *##hhhhhhhh  -- a Unicode character
  53470                   // In GB2312
  53500                   //     *#dddd                 -- A GB2312 code
  53564                 { LET digs = 4
  53594                   rch()
  53617                   IF ch='u' | ch='U' DO { encoding := UTF8;   rch(); LOOP }
  53692                   IF ch='g' | ch='G' DO { encoding := GB2312; rch(); LOOP }
  53767                   TEST encoding=GB2312
  53805                   THEN { 
  53830                          k := readnumber(10, digs)
  53880  //sawritef("rdstrch: GB2312: %i4*n", k)
  53920                        }
  53944                   ELSE { IF ch='#' DO { rch(); digs := 8 }
  54002                          k := readnumber(16, digs)
  54052  //sawritef("rdstrch: Unicode: %x4*n", k)
  54093                        }
  54117                   result2 := TRUE
  54150                   RESULTIS k
  54178                 }
  54195  
  54196        CASE '0':CASE '1':CASE '2':CASE '3':CASE '4':
  54248        CASE '5':CASE '6':CASE '7':
  54282                   // *ooo -- A character escape in octal 
  54339                   k := readnumber(8,3)
  54377                   IF k>255 DO 
  54407                         synerr("Bad string or character constant")
  54473                   result2 := FALSE
  54507                   RESULTIS k
  54535      }
  54541    }
  54545     
  54549    rch()
  54557    result2 := FALSE
  54576    RESULTIS k
  54589  } REPEAT
  54598  
  54599  LET newvec(n) = VALOF
  54621  { treep := treep - n - 1;
  54647    IF treep<=treevec DO
  54670    { errmax := 0  // Make it fatal
  54704      synerr("More workspace needed")
  54740    }
  54744    RESULTIS treep
  54761  }
  54763   
  54765  AND mk1(x) = VALOF
  54784  { LET p = newvec(0)
  54804    p!0 := x
  54815    RESULTIS p
  54828  }
  54830   
  54832  AND mk2(x, y) = VALOF
  54854  { LET p = newvec(1)
  54874    p!0, p!1 := x, y
  54893    RESULTIS p
  54906  }
  54908   
  54910  AND mk3(x, y, z) = VALOF
  54935  { LET p = mk3list
  54953    TEST p THEN mk3list := h1!mk3list
  54989           ELSE p := newvec(2)
  55018    p!0, p!1, p!2 := x, y, z
  55045    RESULTIS p
  55058  }
  55060  
  55061  AND unmk3(p) BE
  55077  { // Only used by cvvaldef and cvass to recover space
  55131    // used by comma nodes.
  55157    h1!p := mk3list
  55175    mk3list := p
  55190  }
  55192   
  55194  AND mk4(x, y, z, t) = VALOF
  55222  { LET p = newvec(3)
  55242    p!0, p!1, p!2, p!3 := x, y, z, t
  55277    RESULTIS p
  55290  }
  55292   
  55294  AND mk5(x, y, z, t, u) = VALOF
  55325  { LET p = newvec(4)
  55345    p!0, p!1, p!2, p!3, p!4 := x, y, z, t, u
  55388    RESULTIS p
  55401  }
  55403   
  55405  AND mk6(x, y, z, t, u, v) = VALOF
  55439  { LET p = newvec(5)
  55459    p!0, p!1, p!2, p!3, p!4, p!5 := x, y, z, t, u, v
  55510    //sawritef("mk6 => %n*n", p*4)
  55543    RESULTIS p
  55556  }
  55558   
  55560  AND mk7(x, y, z, t, u, v, w) = VALOF
  55597  { LET p = newvec(6)
  55617    p!0, p!1, p!2, p!3, p!4, p!5, p!6 := x, y, z, t, u, v, w
  55676    RESULTIS p
  55689  }
  55691   
  55693  AND formtree() =  VALOF
  55717  { LET res = 0
  55731  
  55732    nametablesize := 541
  55755  
  55756    charv      := newvec(256/bytesperword+1)
  55799    charv%0 := 0
  55814    nametable  := newvec(nametablesize) 
  55853    FOR i = 0 TO nametablesize DO nametable!i := 0
  55902    skiptag := 0
  55917    declsyswords()
  55934   
  55936    rec_p, rec_l := level(), rec
  55967   
  55969    token, decval := 0, 0
  55993  
  55994    rdoptstring()
  56010  
  56011    lex()
  56019  //sawritef("formtree: token=%n cis=%n*n", token, cis)
  56073    IF token=s_query DO            // For debugging lex.
  56128    { LET ln, name = ?, ?
  56152      lex()
  56162      ln := lineno & #xFFFFF
  56189      name := opname(token)
  56215  
  56216      SWITCHON token INTO
  56240      { DEFAULT:
  56255          writef("token =%i3 ln=%i5 %12t  *n",   token, ln, name)
  56319          ENDCASE
  56335  
  56336        CASE s_name:
  56355          writef("token =%i3 ln=%i5 %12t  %s*n", token, ln, name, @h3!wordnode)
  56433          ENDCASE  
  56451  
  56452        CASE s_number:
  56473          writef("token =%i3 ln=%i5 %12t  %n*n", token, ln, name, decval)
  56545          ENDCASE  
  56563  
  56564        CASE s_fnum:
  56583          writef("token =%i3 ln=%i5 %12t %13.9e *n", token, ln, name, fltval)
  56659          ENDCASE  
  56677  
  56678        CASE s_string:
  56699        { LET s = @h2!wordnode
  56728          writef("token =%i3 ln=%i5 %12t *"", token, ln, name)
  56789          FOR i = 1 TO s%0 DO
  56817          { LET ch = s%i
  56840            SWITCHON ch INTO
  56867            { DEFAULT:     wrch(ch);    LOOP
  56910  
  56911              CASE '*n': writes("**n"); LOOP
  56954              CASE '*s': writes("**s"); LOOP
  56997              CASE '*p': writes("**p"); LOOP
  57040              CASE '*t': writes("**t"); LOOP
  57083            }
  57095          }
  57105          writes("*"*n")
  57128          ENDCASE
  57144        }  
  57154      }
  57160  
  57161      IF token=s_eof RESULTIS 0
  57191    } REPEAT
  57202  
  57203  rec:res := token=s_section -> rprog(s_section),
  57251             token=s_needs   -> rprog(s_needs), rdblockbody(TRUE)
  57315  //sawritef("section ended with %s*n", opname(token))
  57368    UNLESS token=s_dot | token=s_eof DO synerr("Incorrect termination")
  57438   
  57440    RESULTIS res
  57455  }
  57457   
  57459  AND rprog(thing) = VALOF
  57484  { LET a = 0
  57496    lex()
  57504    a := rbexp()
  57519    UNLESS h1!a=s_string DO synerr("Bad SECTION or NEEDS name")
  57581    RESULTIS mk3(thing, a,
  57606                   token=s_needs -> rprog(s_needs),
  57656                                   rdblockbody(TRUE)) // TRUE=outmost level
  57730  }
  57732   
  57734   
  57736  AND synerr(mess, a) BE
  57759  { LET fno = lineno>>20
  57782    LET ln = lineno & #xFFFFF
  57810    LET filename = sourcenamev!fno
  57843    errcount := errcount + 1
  57870    writef("*nError near ")
  57896    IF filename DO writef("%s", filename)
  57936    writef("[%n]:  ", ln)
  57960    writef(mess, a)
  57978    wrchbuf()
  57990    IF hard DO abort(1000)
  58015    IF errcount > errmax DO
  58041    { writes("*nCompilation aborted*n")
  58079      longjump(fin_p, fin_l)
  58106    }
  58110    nlpending := FALSE
  58131   
  58133    UNTIL token=s_lsect | token=s_rsect |
  58173          token=s_let | token=s_and |
  58209          token=s_dot | token=s_eof | nlpending DO lex()
  58264  
  58265    IF token=s_and DO token := s_let
  58300    longjump(rec_p, rec_l)
  58325  }
  58327   
  58329  LET rdblockbody(outerlevel) = VALOF
  58365  { LET p, l = rec_p, rec_l
  58391    LET a, ln = 0, ?
  58410   
  58412    rec_p, rec_l := level(), recover
  58447  
  58448  recover:  
  58459    IF token=s_semicolon DO lex()
  58491   
  58493    ln := lineno
  58508     
  58512    SWITCHON token INTO
  58534    { CASE s_manifest:
  58555      CASE s_static:
  58574      CASE s_global:
  58593                { LET op = token
  58624                  lex()
  58646                  a := rdsect(rdcdefs, op=s_global->s_colon,s_eq)
  58710                  a := mk4(op, a, rdblockbody(outerlevel), ln)
  58771                  ENDCASE
  58795                }
  58811   
  58813   
  58815      CASE s_let: lex()
  58837                  a := rdef(outerlevel)
  58875                  WHILE token=s_and DO
  58912                  { LET ln1 = lineno
  58947                    lex()
  58971                    a := mk4(s_and, a, rdef(outerlevel), ln1)
  59031                  }
  59049                  a := mk4(s_let, a, rdblockbody(outerlevel), ln)
  59113                  ENDCASE
  59137   
  59139      DEFAULT:    IF outerlevel DO
  59172                  { errmax := 0 // Make it fatal.
  59220                    synerr("Bad outer level declaration")
  59276                  }
  59294                  a := rdseq()
  59323                  UNLESS token=s_rsect DO synerr("Error in command")
  59390   
  59392      CASE s_rsect:IF outerlevel DO lex()
  59432      CASE s_dot:
  59448      CASE s_eof:
  59464    }
  59468   
  59470    rec_p, rec_l := p, l
  59493    RESULTIS a
  59506  }
  59508   
  59510  AND rdseq() = VALOF
  59530  { LET a = 0
  59542    IF token=s_semicolon DO lex()
  59574    a := rcom()
  59588    IF token=s_rsect | token=s_dot | token=s_eof RESULTIS a
  59646    RESULTIS mk3(s_seq, a, rdseq())
  59680  }
  59682  
  59683  AND rdcdefs(sep) = VALOF
  59708  { LET res, id = 0, 0
  59729    LET ptr = @res
  59746    LET p, l = rec_p, rec_l
  59772    LET kexp = 0
  59787  
  59788    { LET ln = lineno
  59808      rec_p, rec_l := level(), recov
  59843      kexp := 0
  59857      id := rname()
  59875      IF token=sep DO kexp := rnexp(0)
  59912      !ptr := mk5(s_constdef, 0, id, kexp, ln)
  59957      ptr := @h2!(!ptr)
  59979  
  59980  recov:IF token=s_semicolon DO lex()
  60016    } REPEATWHILE token=s_name | token=s_flt
  60059   
  60061    rec_p, rec_l := p, l
  60084    RESULTIS res
  60099  }
  60101   
  60103  AND rdsect(r, arg) = VALOF
  60130  // Used only for MANIFEST, STATIC and GLOBAL declarations,
  60189  // SWITCHON commands and blocks.
  60222  { LET tag, res = wordnode, 0
  60251    UNLESS token=s_lsect DO synerr("'{' or '$(' expected")
  60308    lex()
  60316    UNLESS token=s_rsect DO res := r(arg) // Allow { }  MR 22/6/05
  60381    UNLESS token=s_rsect DO synerr("'}' or '$)' expected")
  60438    TEST tag=wordnode THEN lex()
  60469                      ELSE IF wordnode=nulltag DO
  60517                           { token := 0
  60555                             synerr("Untagged '$)' mismatch")
  60615                           }
  60642    // res=0 for empty section brackets { }
  60684    RESULTIS res
  60699  }
  60701  
  60702  AND rnamelist() = VALOF
  60726  { // Read a list of names each possibly prefixed by FLT
  60782    LET a = rname()
  60800    UNLESS token=s_comma RESULTIS a
  60834    lex()
  60842    RESULTIS mk3(s_comma, a, rnamelist())
  60882  }
  60884  
  60885  AND rname() = VALOF
  60905  { // Read a name possibly prefixed by FLT.
  60948    LET a = ?
  60960    LET ff = FALSE
  60977    IF token = s_flt DO
  60999    { ff := TRUE
  61014      lex()
  61024    }
  61028    UNLESS token=s_name DO synerr("Name expected")
  61077    a := wordnode
  61093    lex()
  61101    IF ff RESULTIS mk2(s_flt, a)
  61132    RESULTIS a
  61145  }
  61147   
  61149  LET rbexp() = VALOF
  61169  { LET a, op = 0, token
  61192   
  61194     SWITCHON token INTO
  61217   
  61219     { DEFAULT: synerr("Error in expression")
  61263  
  61264        CASE s_query:  lex()
  61291                       RESULTIS mk1(s_query)
  61334   
  61336        CASE s_true:
  61355        CASE s_false:
  61375        CASE s_name:
  61394        CASE s_string: a := wordnode
  61429                       lex()
  61456                       RESULTIS a
  61488   
  61490        CASE s_number: a := mk2(s_number, decval)
  61538                       lex()
  61565                       RESULTIS a
  61597  
  61598        CASE s_fnum:   UNLESS -128<=exponent<=127 DO
  61649                         synerr("Exponent of floating point constant out of range")
  61731                       floatingchk()
  61766                       a := mk2(s_fnum, fltval)
  61812                       lex()
  61839                       RESULTIS a
  61871  
  61872        CASE s_slct: { LET len, sh, offset = 0, 0, 0  // Inserted 11/7/01
  61944  
  61945                       // Allow   SLCT offset
  61989                       // or      SLCT sh:offset
  62036                       // or      SLCT len:sh:offset
  62087  
  62088                       offset := rnexp(9)
  62128  
  62129                       IF token=s_colon DO
  62170                       { sh := offset
  62206                         offset := rnexp(9)
  62248                       }
  62271                       IF token=s_colon DO
  62312                       { len := sh
  62345                         sh := offset
  62381                         offset := rnexp(9)
  62423                       }
  62446  
  62447                       RESULTIS mk4(s_slct, len, sh, offset)
  62506                     }
  62527   
  62529        CASE s_lparen: a := rnexp(0)
  62564                       UNLESS token=s_rparen DO synerr("')' missing")
  62632                       lex()
  62659                       RESULTIS a
  62691   
  62693        CASE s_valof:  lex()
  62720                       RESULTIS mk2(s_valof, rcom())
  62771   
  62773        CASE s_vecap:  op := s_rv
  62805        CASE s_float:
  62825        CASE s_fix:
  62843        CASE s_lv:
  62860        CASE s_rv:     RESULTIS mk2(op, rnexp(7))
  62908   
  62910        CASE s_fadd:
  62929        CASE s_add:    RESULTIS rnexp(5)
  62968   
  62970        CASE s_sub:    a := rnexp(5)
  63005                       TEST h1!a=s_number THEN h2!a := - h2!a
  63065                                          ELSE a := mk2(s_neg, a)
  63129                       RESULTIS a
  63161        CASE s_fsub:   a := rnexp(5)
  63196                       a := mk2(s_fneg, a)
  63237                       RESULTIS a
  63269   
  63271        CASE s_fabs:
  63290        CASE s_abs:    RESULTIS mk2(op, rnexp(5))
  63338   
  63340        CASE s_not:    RESULTIS mk2(s_not, rnexp(3))
  63391   
  63393        CASE s_table:  lex()
  63420                       RESULTIS mk2(s_table, rexplist())
  63475    }
  63479  }
  63481   
  63483  AND rnexp(n) = VALOF { lex(); RESULTIS rexp(n) }
  63532   
  63534  AND rexp(n) = VALOF
  63554  { LET a, b, p = rbexp(), 0, 0
  63584  
  63585     UNTIL nlpending DO 
  63608     { LET op = token
  63628   
  63630        SWITCHON op INTO
  63653   
  63655        { DEFAULT:       RESULTIS a
  63689   
  63691           CASE s_lparen: lex()
  63721                          b := 0
  63752                          UNLESS token=s_rparen DO b := rexplist()
  63817                          UNLESS token=s_rparen DO synerr("')' missing")
  63888                          lex()
  63918                          a := mk4(s_fnap, a, b, 0)
  63968                          LOOP
  63997   
  63999           CASE s_sbra:   b := rnexp(0)   // Inserted 11/6/02
  64059                          UNLESS token=s_sket DO synerr("']' missing")
  64128                          lex()
  64158                          a := mk3(s_vecap, a, b)
  64206                          LOOP
  64235   
  64237           CASE s_mthap:{ LET e1 = 0
  64272                          lex()
  64302                          UNLESS token=s_lparen DO synerr("'(' missing")
  64373                          lex()
  64403                          b := 0
  64434                          UNLESS token=s_rparen DO b := rexplist()
  64499                          IF b=0 DO synerr("argument expression missing")
  64571                          UNLESS token=s_rparen DO synerr("')' missing")
  64642                          lex()
  64672                          TEST h1!b=s_comma
  64714                          THEN e1 := h2!b
  64754                          ELSE e1 := b
  64791                          a := mk3(s_vecap, mk2(s_rv, e1), a)
  64851                          a := mk4(s_fnap, a, b, 0)
  64901                          LOOP
  64930                        }
  64954   
  64956           CASE s_of:     p := 8; ENDCASE // Inserted 11/7/01
  65016  
  65017           CASE s_vecap:  p := 8; ENDCASE
  65057           CASE s_byteap: p := 8; ENDCASE // Changed from 7 on 16 Dec 1999
  65130           CASE s_fmul:
  65152           CASE s_fdiv:
  65174           CASE s_fmod:
  65196           CASE s_mul:
  65217           CASE s_div:
  65238           CASE s_mod:    p := 6; ENDCASE
  65278  
  65279           CASE s_fadd:
  65301           CASE s_fsub:
  65323           CASE s_add:
  65344           CASE s_sub:    p := 5; ENDCASE
  65384   
  65386           CASE s_feq:CASE s_fle:CASE s_fls:
  65429           CASE s_fne:CASE s_fge:CASE s_fgr:
  65472           CASE s_eq:CASE s_le:CASE s_ls:
  65512           CASE s_ne:CASE s_ge:CASE s_gr:
  65552                          IF n>=4 RESULTIS a
  65595                          b := rnexp(4)
  65633                          a := mk3(op, a, b)
  65676                          WHILE  s_eq<=token<=s_ge |
  65727                                 s_feq<=token<=s_fge DO
  65781                          { LET c = b
  65817                             op := token
  65856                             b := rnexp(4)
  65897                             a := mk3(s_logand, a, mk3(op, c, b))
  65961                          }
  65987                          LOOP
  66016   
  66018           CASE s_lshift:
  66042           CASE s_rshift: IF n>=4 RESULTIS a
  66085                          a := mk3(op, a, rnexp(4))
  66135                          LOOP
  66164  
  66165           CASE s_logand: p := 3; ENDCASE
  66205           CASE s_logor:  p := 2; ENDCASE
  66245           CASE s_eqv:
  66266           CASE s_xor:    p := 1; ENDCASE
  66306   
  66308           CASE s_fcond:
  66331           CASE s_cond:   IF n>=1 RESULTIS a
  66374                          b := rnexp(0)
  66412                          UNLESS token=s_comma DO
  66460                                 synerr("Bad conditional expression")
  66528                          a := mk4(op, a, b, rnexp(0))
  66581                          LOOP
  66610        }
  66618        
  66625        IF n>=p RESULTIS a
  66650        a := mk3(op, a, rnexp(p))
  66682     }
  66687     
  66691     RESULTIS a
  66705  }
  66707   
  66709  LET rexplist() = VALOF
  66732  { LET res, a = 0, rexp(0)
  66758    LET ptr = @res
  66775   
  66777    WHILE token=s_comma DO { !ptr := mk3(s_comma, a, 0)
  66831                             ptr := @h3!(!ptr)
  66876                             a := rnexp(0)
  66917                           }
  66944    !ptr := a
  66956    RESULTIS res
  66971  }
  66973   
  66975  LET rdef(outerlevel) = VALOF
  67004  { LET n = rnamelist()
  67026    LET ln = lineno
  67044  
  67045    SWITCHON token INTO
  67067   
  67069    { CASE s_lparen:
  67088        { LET a = 0
  67106          lex()
  67120          //IF h1!n=s_flt DO synerr("Function name must not have the FLT tag")
  67197          UNLESS h1!n=s_name | h1!n=s_flt DO synerr("Bad function definition")
  67274          IF token=s_name | token=s_flt DO a := rnamelist()
  67332          UNLESS token=s_rparen DO synerr("')' missing")
  67387          lex()
  67401   
  67403          IF token=s_be DO
  67428          { lex()
  67444            RESULTIS mk6(s_rtdef, n, a, rcom(), 0, ln)
  67497          }
  67507   
  67509          IF token=s_eq RESULTIS mk6(s_fndef, n, a, rnexp(0), 0, ln)
  67576   
  67578          synerr("Bad procedure heading")
  67618        }
  67626   
  67628      DEFAULT: synerr("Bad declaration")
  67667   
  67669      CASE s_eq:
  67684          IF outerlevel DO synerr("Bad outer level declaration")
  67747          lex()
  67761          IF token=s_vec DO
  67787          { //IF h1!n=s_flt DO synerr("Vector name must not have the FLT tag")
  67864            UNLESS h1!n=s_name | h1!n=s_flt DO synerr("Name required before = VEC")
  67946              RESULTIS mk4(s_vecdef, n, rnexp(0), ln)
  67998          }
  68008          RESULTIS cvvaldef(n, rexplist(), ln)
  68053    }
  68057  }
  68059  
  68060  AND cvvaldef(lhs, rhs, ln) = VALOF // Added on 28/11/2018
  68118  { // This converts a simultaneous declaration of local
  68173    // variables to a collection of simple declarations connected
  68237    // by ANDs. This is done for the benefit of the FLT feature.
  68300    // The mk3 nodes used for the comma lists are returned to
  68360    // freestore using unmk3.
  68388  
  68389    LET res = 0
  68403    LET ptr = @res
  68420   
  68422    WHILE h1!lhs=s_comma & h1!rhs=s_comma DO
  68465    { LET a = mk4(s_valdef, h2!lhs, h2!rhs, ln)
  68511      !ptr := mk3(s_and, a, 0)
  68540      ptr := @h3!(!ptr)
  68562      unmk3(lhs) // Return the comma nodes to free store.
  68618      unmk3(rhs) // These only change h1!lhs and h1!rhs
  68672      lhs, rhs := h3!lhs, h3!rhs
  68703    }
  68707    IF h1!lhs=s_comma | h1!rhs=s_comma DO
  68747      synerr("Lhs and rhs do not match")
  68786  
  68787    !ptr := mk4(s_valdef, lhs, rhs, ln)
  68825    RESULTIS res
  68840  }
  68842   
  68844  AND cvassign(assop, lhs, rhs, ln) = VALOF // Added on 28/11/2018
  68909  { // This converts a simultaneous assignment to a sequence of
  68971    // simple assignments connected by s_seq. Each simple assigment
  69037    // is given the assignment operator assop.
  69082    // This is done for the benefit of the FLT feature.
  69136    // The mk3 nodes used for the comma lists are returned to
  69196    // freestore using unmk3.
  69224  
  69225    LET res = 0
  69239    LET ptr = @res
  69256   
  69258    WHILE h1!lhs=s_comma & h1!rhs=s_comma DO
  69301    { LET a = mk4(assop, h2!lhs, h2!rhs, ln)
  69344      !ptr := mk3(s_seq, a, 0)
  69373      ptr := @h3!(!ptr)
  69395      unmk3(lhs) // Return the comma nodes to free store.
  69451      unmk3(rhs) // These only change h1!lhs and h1!rhs
  69505      lhs, rhs := h3!lhs, h3!rhs
  69536    }
  69540    IF h1!lhs=s_comma | h1!rhs=s_comma DO
  69580      synerr("Lhs and rhs do not match")
  69619  
  69620    !ptr := mk4(assop, lhs, rhs, ln)
  69655    RESULTIS res
  69670  }
  69672   
  69674  LET rbcom() = VALOF
  69694  { LET a, b, ln = 0, 0, lineno
  69724    LET op = token
  69741   
  69743    SWITCHON op INTO
  69762    { DEFAULT: RESULTIS 0
  69786   
  69788      CASE s_name:CASE s_number:CASE s_fnum:
  69831      CASE s_string:CASE s_lparen:
  69864      CASE s_true:CASE s_false:CASE s_lv:CASE s_rv:CASE s_vecap:
  69927      CASE s_slct:        // Inserted 11/7/01
  69971      CASE s_add:CASE s_sub:CASE s_abs:CASE s_not:
  70020      CASE s_fadd:CASE s_fsub:CASE s_fabs:CASE s_fix:CASE s_float:
  70085      CASE s_table:CASE s_valof:CASE s_query:
  70129              // All tokens that can start an expression.
  70185              a := rexplist()
  70213              op := token
  70237   
  70239              SWITCHON op INTO
  70268              { DEFAULT:
  70291                  IF h1!a=s_fnap DO
  70325                  { h1!a, h4!a := s_rtap, ln
  70368                    RESULTIS a
  70397                  }
  70415                  synerr("Error in command")
  70458                  RESULTIS a
  70485  
  70486                CASE s_ass:      CASE s_fass:
  70530                CASE s_assvecap:
  70561                CASE s_assfmul:  CASE s_assfdiv: CASE s_assfmod:
  70624                CASE s_assfadd:  CASE s_assfsub:
  70671                CASE s_assmul:   CASE s_assdiv:  CASE s_assmod:
  70733                CASE s_assadd:   CASE s_asssub:
  70779                CASE s_asslshift:CASE s_assrshift:
  70828                CASE s_asslogand:CASE s_asslogor:
  70876                CASE s_asseqv:   CASE s_assxor:
  70922                  lex()
  70944                  // Replace a simultaneous assignment by a
  71002                  // sequence of simple assigments.
  71052                  RESULTIS cvassign(op, a, rexplist(), ln)
  71109  
  71110                CASE s_colon:
  71138                  UNLESS h1!a=s_name DO synerr("Unexpected ':'")
  71201                  lex()
  71223                  RESULTIS mk5(op, a, rbcom(), 0, ln)
  71275              }
  71289   
  71291      CASE s_goto:
  71308      CASE s_resultis:
  71329              RESULTIS mk3(op, rnexp(0), ln)
  71372   
  71374      CASE s_if:
  71389      CASE s_unless:
  71408      CASE s_while:
  71426      CASE s_until:
  71444             a := rnexp(0)
  71469             IF token=s_do DO lex()
  71503             RESULTIS mk4(op, a, rcom(), ln)
  71546   
  71548      CASE s_test:
  71565             a := rnexp(0)
  71590             IF token=s_do DO lex()
  71624             b := rcom()
  71647             UNLESS token=s_else DO synerr("ELSE missing")
  71704             lex()
  71721             RESULTIS mk5(s_test, a, b, rcom(), ln)
  71771   
  71773      CASE s_for:
  71789           { LET i, j, k = 0, 0, 0
  71822             lex()
  71839             a := rname()
  71863             UNLESS token=s_eq DO synerr("'=' missing")
  71917             i := rnexp(0)
  71942             UNLESS token=s_to DO synerr("TO missing")
  71995             j := rnexp(0)
  72020             IF token=s_by DO k := rnexp(0)
  72062             IF token=s_do DO lex()
  72096             RESULTIS mk7(s_for, a, i, j, k, rcom(), ln)
  72151           }
  72162   
  72164      CASE s_loop:
  72181      CASE s_break:
  72199      CASE s_return:
  72218      CASE s_finish:
  72237      CASE s_endcase:
  72257              lex()
  72275              RESULTIS mk2(op, ln)
  72308   
  72310      CASE s_switchon:
  72331              a := rnexp(0)
  72357              UNLESS token=s_into DO synerr("INTO missing")
  72415              lex()
  72433              { LET skipln = lineno
  72467                b := rdsect(rdseq)
  72500                UNLESS b DO
  72526                  b := mk2(s_skip, skipln)         // MR 5/4/06
  72588              }
  72602              RESULTIS mk4(s_switchon, a, b, ln)
  72649   
  72651      CASE s_case:
  72668              a := rnexp(0)
  72694              UNLESS token=s_colon DO synerr("Bad CASE label")
  72755              lex()
  72773              RESULTIS mk4(s_case, a, rbcom(), ln)
  72822   
  72824      CASE s_default:
  72844              lex()
  72862              UNLESS token=s_colon DO synerr("Bad DEFAULT label")
  72926              lex()
  72944              RESULTIS mk3(s_default, rbcom(), ln)
  72993   
  72995      CASE s_lsect:
  73013              a := rdsect(rdblockbody, FALSE)
  73057              UNLESS a DO
  73081                a := mk2(s_skip, ln)        // MR 5/4/06
  73136              RESULTIS a
  73159    }
  73163  }
  73165  
  73166  AND rbseq() = VALOF
  73186  { LET a = rbcom()
  73204    WHILE token=s_seq DO
  73227    { LET ln = lineno
  73247      lex()
  73257      a := mk4(s_seq, a, rbcom(), ln)
  73293    }
  73297  }
  73299  
  73300  AND rcom() = VALOF // Added <> 18/07/2010
  73342  // Reads:  BCOM <> BCOM <>...<> BCOM 
  73380  // possibly qualified by repeat, repeatwhile or repeatuntil clauses
  73448  { LET a = rbcom()
  73466   
  73468    // Empty section brackets { } form SKIP nodes, MR 22/6/05
  73528    IF a=0 DO synerr("Error in command")
  73567   
  73569    WHILE token=s_seq DO
  73592    { LET ln = lineno
  73612      lex()
  73622      a := mk4(s_seq, a, rbcom(), ln)
  73658    }
  73662  
  73663    WHILE token=s_repeat | token=s_repeatwhile | token=s_repeatuntil DO
  73733    { LET op, ln = token, lineno
  73764      UNLESS op=s_repeat { a := mk4(op, a, rnexp(0), ln); LOOP }
  73827      a := mk3(op, a, ln)
  73851      lex()
  73861    }
  73865   
  73867    RESULTIS a
  73880  }
  73882  
  73883  LET plist1(x) BE // Rename plist1 and plist to debug the hash table
  73951  { writef("*nName table contents, size = %n*n", nametablesize)
  74013     FOR i = 0 TO nametablesize-1 DO
  74048     { LET p, n = nametable!i, 0
  74079        WHILE p DO p, n := p!1, n+1
  74113        writef("%i3:%n", i, n)
  74142        p := nametable!i
  74165        WHILE p DO { writef(" %s", p+2); p := p!1  }
  74216        newline()
  74232     }
  74237  }
  74239  
  74240  LET plist(x, n, d) BE
  74262  { LET size, ln = 0, 0
  74284    LET v = TABLE 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  74340  
  74341    IF x=0 DO { writes("Nil"); RETURN  }
  74380   
  74382    SWITCHON h1!x INTO
  74403    { CASE s_number:
  74422                   { LET val = h2!x
  74456                     TEST -1000000<=val<=1000000
  74503                     THEN writef("NUMBER: %n", val)
  74553                     ELSE writef("NUMBER: #x%x8", val)
  74606                     RETURN
  74632                   }
  74651  
  74652      CASE s_fnum:   writef("FNUM: %14.6f", h2!x); RETURN
  74708  
  74709      CASE s_name:   writef("NAME: %s", x+2); RETURN
  74760   
  74762      CASE s_string:
  74781                  { LET s = x+1
  74811                    writef("STRING: *"")
  74850                    FOR i = 1 TO s%0 SWITCHON s%i INTO
  74903                    { DEFAULT:   wrch(s%i); LOOP
  74950                      CASE '*n': writes("**n"); LOOP
  75001                      CASE '*p': writes("**p"); LOOP
  75052                      CASE '*s': writes("**s"); LOOP
  75103                      CASE '*t': writes("**t"); LOOP
  75154                    }
  75174                    writes("*"")
  75205                    RETURN
  75230                  }
  75248   
  75250        CASE s_for:    size, ln := 6, h7!x;  ENDCASE
  75301   
  75303        CASE s_fndef:CASE s_rtdef:
  75336                       size, ln := 4, h6!x;  ENDCASE
  75387  
  75388        CASE s_fcond:
  75408        CASE s_cond:
  75427        CASE s_slct:       // Inserted 11/7/01
  75472                       size := 4;            ENDCASE
  75523   
  75525        CASE s_test:CASE s_constdef:
  75560                       size, ln := 4, h5!x;  ENDCASE
  75611   
  75613        CASE s_needs:CASE s_section:CASE s_vecap:CASE s_byteap:CASE s_fnap:
  75687        CASE s_of:  // Inserted 11/7/01
  75725        CASE s_fmul:CASE s_fdiv:CASE s_fmod:
  75768        CASE s_fadd:CASE s_fsub:
  75799        CASE s_mul:CASE s_div:CASE s_mod:CASE s_add:CASE s_sub:
  75861        CASE s_feq:CASE s_fne:CASE s_fls:CASE s_fgr:CASE s_fle:CASE s_fge:
  75934        CASE s_eq:CASE s_ne:CASE s_ls:CASE s_gr:CASE s_le:CASE s_ge:
  76001        CASE s_lshift:CASE s_rshift:CASE s_logand:CASE s_logor:
  76063        CASE s_eqv:CASE s_xor:CASE s_comma:
  76105        CASE s_seq:
  76123                       size := 3;            ENDCASE
  76174                       
  76196        CASE s_valdef:CASE s_vecdef:
  76231                       size, ln := 3, h4!x;  ENDCASE
  76282  
  76283        CASE s_colon:
  76303                       size, ln := 3, h5!x;  ENDCASE
  76354   
  76356        CASE s_and:
  76374        CASE s_ass:CASE s_fass:
  76404        CASE s_assvecap:
  76427        CASE s_assfmul:  CASE s_assfdiv: CASE s_assfmod:
  76482        CASE s_assfadd:  CASE s_assfsub:
  76521        CASE s_assmul:   CASE s_assdiv:  CASE s_assmod:
  76575        CASE s_assadd:   CASE s_asssub:
  76613        CASE s_asslshift:CASE s_assrshift:
  76654        CASE s_asslogand:CASE s_asslogor:
  76694        CASE s_asseqv:   CASE s_assxor:
  76732        CASE s_rtap:CASE s_if:CASE s_unless:
  76775        CASE s_while:CASE s_until:CASE s_repeatwhile:
  76827        CASE s_repeatuntil:
  76853        CASE s_switchon:CASE s_case:CASE s_let:
  76899        CASE s_manifest:CASE s_static:CASE s_global:
  76950                       size, ln := 3, h4!x;  ENDCASE
  77001   
  77003        CASE s_valof:CASE s_lv:CASE s_rv:CASE s_neg:CASE s_not:
  77065        CASE s_table:CASE s_abs:
  77096        CASE s_fabs:CASE s_fneg:CASE s_fix:CASE s_float:
  77151        CASE s_flt:
  77169                       size := 2;            ENDCASE
  77220   
  77222        CASE s_goto:CASE s_resultis:CASE s_repeat:CASE s_default:
  77286                       size, ln := 2, h3!x;  ENDCASE
  77337   
  77339        CASE s_true:CASE s_false:CASE s_query:
  77384                       size := 1;            ENDCASE
  77435        
  77442        CASE s_skip: // MR 22/6/05
  77475        CASE s_loop:CASE s_break:CASE s_return:
  77521        CASE s_finish:CASE s_endcase:
  77557                       size, ln := 1, h2!x;  ENDCASE
  77608  
  77609        DEFAULT:       size := 1
  77640     }
  77645   
  77647     IF n=d DO { writes("Etc"); RETURN }
  77686   
  77688  //   writef("Op %n", h1!x)
  77715     writef(opname(h1!x), h1!x)
  77745  // IF ln>0 DO writef("  line %n", ln)
  77783     IF ln>0 DO
  77797     { LET fno = ln>>20
  77819       LET lno = ln & #xFFFFF
  77847       LET filename = sourcenamev!fno
  77883       writef("  ")
  77901       IF filename DO writef("%s", filename)
  77944       writef("[%n]", lno)
  77969     }
  77974     FOR i = 2 TO size DO { newline()
  78010                            FOR j=0 TO n-1 DO writes( v!j )
  78068                            writes("**-")
  78108                            v!n := i=size->"  ","! "
  78159                            plist(h1!(x+i-1), n+1, d)
  78211                          }
  78237  }
  78239   
  78241  AND opname(op) = VALOF SWITCHON op INTO
  78281  { DEFAULT:            writef("*nUnknown opname = %n*n", op)
  78341                        RESULTIS "Op %n"
  78380  
  78381    CASE s_abs:         RESULTIS "ABS"
  78418    CASE s_and:         RESULTIS "AND"
  78455    CASE s_ass:         RESULTIS "ASS"
  78492    CASE s_assdiv:      RESULTIS "ASSDIV"
  78532    CASE s_asseqv:      RESULTIS "ASSEQV"
  78572    CASE s_assfdiv:     RESULTIS "ASSFDIV"
  78613    CASE s_assfmod:     RESULTIS "ASSFMOD"
  78654    CASE s_assfsub:     RESULTIS "ASSFSUB"
  78695    CASE s_assfmul:     RESULTIS "ASSFMUL"
  78736    CASE s_assfadd:     RESULTIS "ASSFADD"
  78777    CASE s_asslogand:   RESULTIS "ASSLOGAND"
  78820    CASE s_asslogor:    RESULTIS "ASSLOGOR"
  78862    CASE s_asslshift:   RESULTIS "ASSLSHIFT"
  78905    CASE s_asssub:      RESULTIS "ASSSUB"
  78945    CASE s_assmul:      RESULTIS "ASSMUL"
  78985    CASE s_assxor:      RESULTIS "ASSXOR"
  79025    CASE s_assadd:      RESULTIS "ASSADD"
  79065    CASE s_assmod:      RESULTIS "ASSMOD"
  79105    CASE s_assrshift:   RESULTIS "ASSRSHIFT"
  79148    CASE s_assvecap:    RESULTIS "ASSVECAP"
  79190    CASE s_be:          RESULTIS "BE"
  79226    CASE s_by:          RESULTIS "BY"
  79262    CASE s_break:       RESULTIS "BREAK"
  79301    CASE s_byteap:      RESULTIS "BYTEAP"
  79341    CASE s_case:        RESULTIS "CASE"
  79379    CASE s_colon:       RESULTIS "COLON"
  79418    CASE s_comma:       RESULTIS "COMMA"
  79457    CASE s_cond:        RESULTIS "COND"
  79495    CASE s_constdef:    RESULTIS "CONSTDEF"
  79537    CASE s_datalab:     RESULTIS "DATALAB"
  79578    CASE s_default:     RESULTIS "DEFAULT"
  79619    CASE s_div:         RESULTIS "DIV"
  79656    CASE s_do:          RESULTIS "DO"
  79692    CASE s_dot:         RESULTIS "DOT"
  79729    CASE s_else:        RESULTIS "ELSE"
  79767    CASE s_eof:         RESULTIS "EOF"
  79804    CASE s_endcase:     RESULTIS "ENDCASE"
  79845    CASE s_endfor:      RESULTIS "ENDFOR"
  79885    CASE s_endproc:     RESULTIS "ENDPROC"
  79926    CASE s_entry:       RESULTIS "ENTRY"
  79965    CASE s_eq:          RESULTIS "EQ"
  80001    CASE s_eqv:         RESULTIS "EQV"
  80038    CASE s_fabs:        RESULTIS "FABS"
  80076    CASE s_fadd:        RESULTIS "FADD"
  80114    CASE s_false:       RESULTIS "FALSE"
  80153    CASE s_fass:        RESULTIS "FASS"
  80191    CASE s_fcond:       RESULTIS "FCOND"
  80230    CASE s_fdiv:        RESULTIS "FDIV"
  80268    CASE s_feq:         RESULTIS "FEQ"
  80305    CASE s_fge:         RESULTIS "FGE"
  80342    CASE s_fgr:         RESULTIS "FGR"
  80379    CASE s_fglobal:     RESULTIS "FGLOBAL"
  80420    CASE s_finish:      RESULTIS "FINISH"
  80460    CASE s_fix:         RESULTIS "FIX"
  80497    CASE s_fle:         RESULTIS "FLE"
  80534    CASE s_float:       RESULTIS "FLOAT"
  80573    CASE s_flt:         RESULTIS "FLT"
  80610    CASE s_fls:         RESULTIS "FLS"
  80647    CASE s_fltop:       RESULTIS "FLTOP"
  80686    CASE s_fmanifest:   RESULTIS "FMANIFEST"
  80729    CASE s_fmod:        RESULTIS "FMOD"
  80767    CASE s_fnap:        RESULTIS "FNAP"
  80805    CASE s_fnrn:        RESULTIS "FNRN"
  80843    CASE s_fndef:       RESULTIS "FNDEF"
  80882    CASE s_fne:         RESULTIS "FNE"
  80919    CASE s_fneg:        RESULTIS "FNEG"
  80957    CASE s_fnum:        RESULTIS "FNUM"
  80995    CASE s_fmul:        RESULTIS "FMUL"
  81033    CASE s_fstatic:     RESULTIS "FSTATIC"
  81074    CASE s_fsub:        RESULTIS "FSUB"
  81112  
  81113    CASE s_for:         RESULTIS "FOR"
  81150    CASE s_ge:          RESULTIS "GE"
  81186    CASE s_get:         RESULTIS "GET"
  81223    CASE s_getbyte:     RESULTIS "GETBYTE"
  81264    CASE s_global:      RESULTIS "GLOBAL"
  81304    CASE s_goto:        RESULTIS "GOTO"
  81342    CASE s_gr:          RESULTIS "GR"
  81378    CASE s_if:          RESULTIS "IF"
  81414    CASE s_into:        RESULTIS "INTO"
  81452    CASE s_itemn:       RESULTIS "ITEMN"
  81491    CASE s_jf:          RESULTIS "JF"
  81527    CASE s_jt:          RESULTIS "JT"
  81563    CASE s_jump:        RESULTIS "JUMP"
  81601    CASE s_lab:         RESULTIS "LAB"
  81638    CASE s_le:          RESULTIS "LE"
  81674    CASE s_let:         RESULTIS "LET"
  81711    CASE s_lf:          RESULTIS "LF"
  81747    CASE s_lg:          RESULTIS "LG"
  81783    CASE s_ll:          RESULTIS "LL"
  81819    CASE s_llg:         RESULTIS "LLG"
  81856    CASE s_lll:         RESULTIS "LLl"
  81893    CASE s_llp:         RESULTIS "LLP"
  81930    CASE s_ln:          RESULTIS "LN"
  81966    CASE s_logand:      RESULTIS "LOGAND"
  82006    CASE s_logor:       RESULTIS "LOGOR"
  82045    CASE s_loop:        RESULTIS "LOOP"
  82083    CASE s_lp:          RESULTIS "LP"
  82119    CASE s_lparen:      RESULTIS "LPAREN"
  82159    CASE s_ls:          RESULTIS "LS"
  82195    CASE s_lsect:       RESULTIS "LSECT"
  82234    CASE s_lshift:      RESULTIS "LSHIFT"
  82274    CASE s_lstr:        RESULTIS "LSTR"
  82312    CASE s_lv:          RESULTIS "LV"
  82348    CASE s_manifest:    RESULTIS "MANIFEST"
  82390    CASE s_mthap:       RESULTIS "MTHAP"
  82429    CASE s_mul:         RESULTIS "MUL"
  82466    CASE s_name:        RESULTIS "NAME"
  82504    CASE s_ne:          RESULTIS "NE"
  82540    CASE s_needs:       RESULTIS "NEEDS"
  82579    CASE s_neg:         RESULTIS "NEG"
  82616    CASE s_none:        RESULTIS "NONE"
  82654    CASE s_not:         RESULTIS "NOT"
  82691    CASE s_number:      RESULTIS "NUMBER"
  82731    CASE s_of:          RESULTIS "OF"
  82767    CASE s_add:         RESULTIS "ADD"
  82804    CASE s_putbyte:     RESULTIS "PUTBYTE"
  82845    CASE s_query:       RESULTIS "QUERY"
  82884    CASE s_mod:         RESULTIS "MOD"
  82921    CASE s_repeat:      RESULTIS "REPEAT"
  82961    CASE s_repeatuntil: RESULTIS "REPEATUNTIL"
  83006    CASE s_repeatwhile: RESULTIS "REPEATWHILE"
  83051    CASE s_res:         RESULTIS "RES"
  83088    CASE s_resultis:    RESULTIS "RESULTIS"
  83130    CASE s_return:      RESULTIS "RETURN"
  83170    CASE s_rparen:      RESULTIS "RPAREN"
  83210    CASE s_rsect:       RESULTIS "RSECT"
  83249    CASE s_rshift:      RESULTIS "RSHIFT"
  83289    CASE s_rstack:      RESULTIS "RSTACK"
  83329    CASE s_rtap:        RESULTIS "RTAP"
  83367    CASE s_rtdef:       RESULTIS "RTDEF"
  83406    CASE s_rtrn:        RESULTIS "RTRN"
  83444    CASE s_rv:          RESULTIS "RV"
  83480    CASE s_save:        RESULTIS "SAVE"
  83518    CASE s_sbra:        RESULTIS "SBRA"
  83556    CASE s_section:     RESULTIS "SECTION"
  83597    CASE s_semicolon:   RESULTIS "SEMICOLON"
  83640    CASE s_seq:         RESULTIS "SEQ"
  83677    CASE s_sg:          RESULTIS "SG"
  83713    CASE s_sket:        RESULTIS "SKET"
  83751    CASE s_skip:        RESULTIS "SKIP"
  83789    CASE s_sl:          RESULTIS "SL"
  83825    CASE s_slct:        RESULTIS "SLCT"
  83863    CASE s_selld:       RESULTIS "SELLD"
  83902    CASE s_selst:       RESULTIS "SELST"
  83941    CASE s_sp:          RESULTIS "SP"
  83977    CASE s_stack:       RESULTIS "STACK"
  84016    CASE s_static:      RESULTIS "STATIC"
  84056    CASE s_stind:       RESULTIS "STIND"
  84095    CASE s_store:       RESULTIS "STORE"
  84134    CASE s_string:      RESULTIS "STRING"
  84174    CASE s_sub:         RESULTIS "SUB"
  84211    CASE s_switchon:    RESULTIS "SWITCHON"
  84253    CASE s_table:       RESULTIS "TABLE"
  84292    CASE s_test:        RESULTIS "TEST"
  84330    CASE s_to:          RESULTIS "TO"
  84366    CASE s_true:        RESULTIS "TRUE"
  84404    CASE s_unless:      RESULTIS "UNLESS"
  84444    CASE s_until:       RESULTIS "UNTIL"
  84483    CASE s_valdef:      RESULTIS "VALDEF"
  84523    CASE s_valof:       RESULTIS "VALOF"
  84562    CASE s_vec:         RESULTIS "VEC"
  84599    CASE s_vecap:       RESULTIS "VECAP"
  84638    CASE s_vecdef:      RESULTIS "VECDEF"
  84678    CASE s_while:       RESULTIS "WHILE"
  84717    CASE s_xor:         RESULTIS "XOR"
  84754  }
  84756  
  84757  AND flopname(flop) = VALOF SWITCHON flop INTO
  84803  { DEFAULT:            writef("*nUnknown flopname = %n*n", flop)
  84867                        abort(999)
  84900                        RESULTIS "Flop %n"
  84941  
  84942    CASE fl_mk:         RESULTIS "MK"
  84978    CASE fl_float:      RESULTIS "FLOAT"
  85017    CASE fl_fix:        RESULTIS "FIX"
  85054    CASE fl_neg:        RESULTIS "NEG"
  85091    CASE fl_abs:        RESULTIS "ABS"
  85128    CASE fl_mul:        RESULTIS "MUL"
  85165    CASE fl_mod:        RESULTIS "MOD"
  85202    CASE fl_div:        RESULTIS "DIV"
  85239    CASE fl_add:        RESULTIS "ADD"
  85276    CASE fl_sub:        RESULTIS "SUB"
  85313    CASE fl_eq:         RESULTIS "EQ"
  85349    CASE fl_ne:         RESULTIS "NE"
  85385    CASE fl_ls:         RESULTIS "LS"
  85421    CASE fl_gr:         RESULTIS "GR"
  85457    CASE fl_le:         RESULTIS "LE"
  85493    CASE fl_ge:         RESULTIS "GE"
  85529  }
  85531  
  85532  AND sfname(sfop) = VALOF SWITCHON sfop INTO
  85576  { DEFAULT:       writef("sfname: bad sfop = %n*n", sfop)
  85633                   RESULTIS "UNKNOWN"
  85669  
  85670    CASE sf_none:   RESULTIS "NONE"
  85704    CASE sf_vecap:  RESULTIS "VECAP"
  85739    CASE sf_fmul:   RESULTIS "FMUL"
  85773    CASE sf_fdiv:   RESULTIS "FDIV"
  85807    CASE sf_fmod:   RESULTIS "FMOD"
  85841    CASE sf_fadd:   RESULTIS "FADD"
  85875    CASE sf_fsub:   RESULTIS "FSUB"
  85909    CASE sf_mul:    RESULTIS "MUL"
  85942    CASE sf_div:    RESULTIS "DIV"
  85975    CASE sf_mod:    RESULTIS "MOD"
  86008    CASE sf_add:    RESULTIS "ADD"
  86041    CASE sf_sub:    RESULTIS "SUB"
  86074    CASE sf_lshift: RESULTIS "LSHIFT"
  86110    CASE sf_rshift: RESULTIS "RSHIFT"
  86146    CASE sf_logand: RESULTIS "LOGAND"
  86182    CASE sf_logor:  RESULTIS "LOGOR"
  86217    CASE sf_eqv:    RESULTIS "EQV"
  86250    CASE sf_xor:    RESULTIS "XOR"
  86283  }
  86285  
  86286  //.
  86290  
  86291  //SECTION "TRN"
  86307  
  86308  //GET "libhdr"
  86323  //GET "bcplfecg"
  86340   
  86342  GLOBAL  {
  86352  trnext:trng
  86364  trans; destlabel; declnames; decldyn
  86401  declstat; checkdistinct; addname; cellwithname
  86448  transdef; scanlabel
  86468  decllabels; undeclare
  86490  jumpcond; transswitch; transfor
  86522  assop2op; op2sfop; cv2flt
  86548  assign; load; fnbody; loadlv; loadlist
  86587  isflt; isconst; iszero; evalconst; transname; xref
  86638  nextlab; labnumber
  86657  newblk
  86664  dvec; dvece; dvecp; dvect
  86690  caselist; casecount
  86710  context; comline; procname
  86737  resultlab; defaultlab; endcaselab
  86771  looplab; breaklab; ssp; vecssp
  86802  gdeflist; gdefcount
  86822  outstring; out1; out2; out3; out4
  86856  }
  86858  
  86859  LET nextlab() = VALOF
  86881  { labnumber := labnumber + 1
  86910    RESULTIS labnumber
  86931  }
  86933   
  86935  AND trnerr(mess, a, b) BE
  86961  { LET fno = comline>>20
  86985    LET lno = comline & #xFFFFF
  87015    LET filename = sourcenamev!fno
  87048    writes("Error ")
  87067    UNLESS procname=0 DO writef("in %s ", @h3!procname)
  87121    writef("near ")
  87139    IF filename DO writef("%s", filename)
  87179    writef("[%n]: ", lno)
  87203    writef(mess, a, b)
  87224    newline()
  87236    IF hard DO abort(1000)
  87261    errcount := errcount + 1
  87288    IF errcount >= errmax DO { writes("*nCompilation aborted*n")
  87351                               longjump(fin_p, fin_l)
  87403                             }
  87432  }
  87434  
  87435  AND newblk(x, y, z) = VALOF
  87463  { LET p = dvect - 3
  87483    IF dvece>p DO { errmax := 0        // Make it fatal.
  87538                    trnerr("More workspace needed")
  87588                  }
  87606    p!0, p!1, p!2 := x, y, z
  87633    dvect := p
  87646    RESULTIS p
  87659  }
  87661  
  87662  AND translate(x) BE
  87682  { dvec,  dvect := treevec, treep
  87715    h1!dvec, h2!dvec, h3!dvec := 0, 0, 0
  87754    dvece := dvec+3
  87772    dvecp := dvece
  87789  //selectoutput(sysprint)
  87814    FOR i = 0 TO nametablesize-1 DO
  87848    { LET name = nametable!i
  87875      UNTIL name=0 DO
  87895      { LET next = h2!name
  87920        h2!name := 0 // Mark undeclared
  87958  //   writef("Undeclare %s*n", name+2)
  87996        name := next
  88015      }
  88021    }
  88025  
  88026    gdeflist, gdefcount := 0, 0
  88056    caselist, casecount, defaultlab := 0, -1, 0
  88102    resultlab, breaklab, looplab, endcaselab := -2, -2, -2, -2
  88163    context, comline, procname, labnumber := 0, 1, 0, 0
  88217    ssp, vecssp := savespacesize, savespacesize
  88263  
  88264    WHILE x~=0 & (h1!x=s_section | h1!x=s_needs) DO
  88314    { LET op, a = h1!x, h2!x
  88341      out1(op)
  88354      outstring(@h2!a)
  88375      x:=h3!x
  88387    }
  88391  
  88392    trans(x, 0)
  88406    out2(s_global, gdefcount)
  88434    UNTIL gdeflist=0 DO { out2(h2!gdeflist, h3!gdeflist)
  88489                          gdeflist := h1!gdeflist
  88537                        }  
  88563  }
  88565  
  88566  LET trnext(next) BE { IF next<0 DO out1(s_rtrn)
  88614                        IF next>0 DO out2(s_jump, next)
  88668                      }
  88690   
  88692  LET trans(x, next) BE
  88714  // x       is the command to translate
  88753  // next<0  compile x followed by RTRN
  88791  // next>0  compile x followed by JUMP next
  88834  // next=0  compile x only
  88860  { LET op, sfop, sw, ff = ?, ?, FALSE, FALSE
  88904    IF x=0 DO { trnext(next); RETURN }
  88941  
  88942    op := h1!x // op is the leading operator of
  88988               // the command to translate.
  89030  
  89031    SWITCHON op INTO
  89050    { DEFAULT: trnerr("Compiler error in Trans, op = %s",
  89106                      opname(op))
  89138               RETURN
  89158   
  89160      CASE s_let:
  89176      { LET cc = casecount
  89201        LET e, s, s1 = dvece, ssp, 0
  89236        LET v = vecssp
  89257        casecount := -1 // Disallow CASE and DEFAULT labels
  89315        context, comline := x, h4!x
  89349        declnames(h2!x)
  89371        checkdistinct(e)
  89394        vecssp, s1 := ssp, ssp
  89423        ssp := s
  89438        context, comline := x, h4!x
  89472        transdef(h2!x)
  89493        UNLESS ssp=s1 DO trnerr("Lhs and rhs do not match")
  89551        UNLESS ssp=vecssp DO { ssp := vecssp; out2(s_stack, ssp) }
  89616        out1(s_store)
  89636        decllabels(h3!x)
  89659        trans(h3!x, next)
  89683        vecssp := v
  89701        UNLESS ssp=s DO out2(s_stack, s)
  89740        ssp := s
  89755        casecount := cc
  89777        undeclare(e)
  89796        RETURN
  89809      }
  89815   
  89817      CASE s_static:
  89836      CASE s_global:
  89855      CASE s_manifest:
  89876      { LET cc = casecount
  89901        LET e, s = dvece, ssp
  89929        AND y, n = h2!x, 0
  89954        LET prevk = 0 // The previous integer or floating point value
  90022        LET prevt = 0 // =0, s_notflt or s_flt
  90067           
  90077        casecount := -1 // Disallow CASE and DEFAULT labels
  90135        context, comline := x, h4!x
  90169   
  90171        UNTIL y=0 DO
  90190        { LET name = h3!y
  90214          LET fop = op    // = s_static, s_global or s_manifest
  90276          ff := FALSE     // ff will only be TRUE for static and manifest
  90348                          // names with the FLT tag. If TRUE the value of
  90420                          // the constant will be a floating point number.
  90493  
  90494          context, comline := y, h5!y
  90530  
  90531          // If the name is prefixed by FLT remove the prefix and
  90595          // modify fop as follows
  90628          //     s_static   -> s_fstatic
  90667          //     s_manifest -> s_fmanifest
  90708          // and s_global   -> s_fglobal
  90747  
  90748          IF h1!name=s_flt DO name, fop := h2!name, op | s_fltbit
  90812  
  90813          // If fop is s_fstatic or s_fmanifest the constant
  90872          // expression in evaluated in an FLT context, in all
  90933          // other cases it is evaluated in a non FLT context.
  90994  
  90995          IF fop=s_fstatic | fop=s_fmanifest DO ff := TRUE
  91052  
  91053          TEST h4!y
  91071          THEN { //sawritef("Calling evalconst*n")
  91120                 //plist(h4!y, 0, 5)
  91155                 //newline()
  91182                 n := evalconst(h4!y, ff)
  91222                 //writef("giving n=%n*n", n)
  91266                 //abort(1000)
  91295               }
  91310          ELSE { // The constant expression was not given so the
  91373                 // value is chosen as follows:
  91419  
  91420  //sawritef("*nname=%s fop=%i3 fopname=%10t prevt=%i3 prevk=%x8(%i3) ff=%i3*n",
  91499  //    @h3!name, fop, opname(fop), prevt, prevk, prevk, ff)
  91558  //abort(9876)
  91572                 // If there was no previous value the value is
  91634                 // 0 or 0.0.
  91662                 TEST prevt=0
  91690                 THEN { n := ff -> flt0, 0
  91731  //sawritef("Setting n=%x8(%i3)*n", n, n)
  91772                      }
  91794                 ELSE { // For s_static    the value is 0
  91850  
  91851                        IF fop=s_static DO n := 0
  91899  
  91900                        // for s_fstatic   the value is 0.0
  91958  
  91959                        IF fop=s_fstatic DO n := flt0
  92011  
  92012                        // for s_manifest  the value is one larger than the
  92086                        //                 previous value is converted to
  92158                        //                 integer, if necessary.
  92222  
  92223                        IF fop=s_manifest DO
  92266                        { IF prevt=s_flt DO n := sys(Sys_flt, fl_fix, n)
  92337                          n := n+1
  92370                        }
  92394  
  92395                        // for s_fmanifest the value is 1.0 larger than the
  92469                        //                 previous value is converted to
  92541                        //                 floating point, if necessary.
  92612  
  92613                        IF fop=s_fmanifest DO
  92657                        { IF prevt=s_notflt DO n := sys(Sys_flt, fl_float, n)
  92733                          n := sys(Sys_flt, fl_add, n, flt1)
  92792                        }
  92816  
  92817                        // For s_global and s_fglobal the value is a
  92884                        // global number one larger than the previous one.
  92957  
  92958                        IF fop=s_global | fop=s_fglobal DO n := n + 1
  93026                      }
  93048  
  93049               }
  93064  
  93065          // prevk is the previous value (integer or floating point).
  93133          // prevt is s_flt if the previous value was floating point.
  93201          //       it is s_notflt the previous value was an integer.
  93268  
  93269          prevk := n
  93288          prevt := ff -> s_flt, s_notflt
  93327  //sawritef("setting prevk=%n prevt=%n*n", prevk, prevt)
  93383  
  93384  //sawritef("name=%s fop=%i3 fopname=%10t prevt=%i3 prevk=%x8(%i3) ff=%i3 n=%x8(%i3)*n",
  93472  //    @h3!name, fop, opname(fop), prevt, prevk, prevk, ff, n, n)
  93537  
  93538          IF op=s_static DO
  93564          { LET k = n
  93584            n := nextlab()      // n is now the label for the static variable
  93660            out2(s_datalab, n)
  93689            out2(s_itemn, k)
  93716          }
  93726  
  93727          IF op=s_global UNLESS 0<=n<=65535 DO
  93772            trnerr("Global number %n too large for: %s*n", n, @h3!name)
  93842  
  93843          // n is a global number, a manifest value or a label for a
  93910          // static variable.
  93938          addname(name, fop, n)
  93968          IF xrefing DO xref(name,
  94001                             (fop=s_global->"G:",
  94049                              fop=s_fglobal->"FG:",
  94099                              fop=s_static->"S:",
  94147                              fop=s_fstatic->"FS:",
  94197                              fop=s_manifest->"M:",
  94247                              fop=s_fmanifest->"FM:",
  94299                              "??:"),
  94335                             n,
  94365                             s_constdef
  94403                            )
  94431          y := h2!y
  94449        }
  94457   
  94459        decllabels(h3!x)
  94482        trans(h3!x, next)
  94506        ssp := s
  94521        casecount := cc
  94543        undeclare(e)
  94562        RETURN
  94575      }
  94581   
  94583      CASE s_assmul: // Assignment operators that might
  94637      CASE s_assdiv: // be promoted to floating point.
  94690      CASE s_assmod:
  94709      CASE s_assadd:
  94728      CASE s_asssub:
  94747      CASE s_ass:
  94763        // Note that simultaneous assignments have already been
  94825        // replaced by sequences of simple assignments.
  94879        // Convert op:= to #op:= if either operand has the FLT tag.
  94945        UNLESS isflt(h3!x) | isflt(h2!x) DO
  94987        { // Compile a non FLT assignment
  95027          context, comline := x, h4!x
  95063          op := assop2op(op)
  95090          assign(h2!x, h3!x, FALSE, op)
  95128          trnext(next)
  95149          RETURN
  95164        }
  95172  
  95173        // Promote op:= to #op:=
  95204        op := cv2flt(op)
  95227        h1!x := op
  95244        // Fall through
  95266  
  95267      CASE s_assfmul: // The floating point assignment operators
  95330      CASE s_assfdiv:
  95350      CASE s_assfmod:
  95370      CASE s_assfadd:
  95390      CASE s_assfsub:
  95410      CASE s_fass:
  95427        context, comline := x, h4!x
  95461        op := assop2op(op)
  95486        assign(h2!x, h3!x, TRUE, op)
  95521        trnext(next)
  95540        RETURN
  95553  
  95554      CASE s_assvecap:  // All the other assignment operators
  95614      CASE s_asslshift:
  95636      CASE s_assrshift:
  95658      CASE s_asslogand:
  95680      CASE s_asslogor:
  95701      CASE s_asseqv:
  95720      CASE s_assxor:
  95739        context, comline := x, h4!x
  95773        op := assop2op(op)
  95798        assign(h2!x, h3!x, FALSE, op)
  95834        trnext(next)
  95853        RETURN
  95866   
  95868      CASE s_rtap:
  95885      { LET s = ssp
  95903        context, comline := x, h4!x
  95937        ssp := ssp+savespacesize
  95968        out2(s_stack, ssp)
  95993        loadlist(h3!x) // Load arguments in non FLT mode
  96048        load(h2!x, FALSE)
  96072        out2(s_rtap, s)
  96094        ssp := s
  96109        trnext(next)
  96128        RETURN
  96141      }
  96147   
  96149      CASE s_goto:
  96166        context, comline := x, h3!x
  96200        load(h2!x, FALSE)
  96224        out1(s_goto)
  96243        ssp := ssp-1
  96262        RETURN
  96275   
  96277      CASE s_colon:
  96295        context, comline := x, h5!x
  96329        out2(s_lab, h4!x)
  96353        trans(h3!x, next)
  96377        RETURN
  96390   
  96392      CASE s_unless: sw := TRUE
  96422      CASE s_if:
  96437        context, comline := x, h4!x
  96471  
  96472        { // Optimise IF exp BREAK/LOOP/ENDCASE, if possible.
  96532          LET bodyop = h1!(h3!x)
  96563          LET destlab = destlabel(bodyop)
  96603          // destlab is the destination label if the body
  96659          // was BREAK, LOOP or ENDCASE. Otherwise it is zero.
  96720          IF destlab>0 DO
  96744          { jumpcond(h2!x, ~sw, destlab)
  96783            trnext(next)
  96806  //sawritef("IF exp BREAK/LOOP/ENDCASE optimised*n")
  96858            RETURN
  96875          }
  96885        }
  96893  
  96894        TEST next>0 THEN { jumpcond(h2!x, sw, next)
  96944                           trans(h3!x, next)
  96987                         }
  97012                    ELSE { LET l = nextlab()
  97055                           jumpcond(h2!x, sw, l)
  97102                           trans(h3!x, next)
  97145                           out2(s_lab, l)
  97185                           trnext(next)
  97223                         }
  97248        RETURN
  97261   
  97263      CASE s_test:
  97280      { LET l, m = nextlab(), 0
  97310        context, comline := x, h5!x
  97344        jumpcond(h2!x, FALSE, l)
  97375           
  97385        TEST next=0 THEN { m := nextlab(); trans(h3!x, m) }
  97443                    ELSE trans(h3!x, next)
  97484                       
  97506        out2(s_lab, l)
  97527        trans(h4!x, next)
  97551        UNLESS m=0 DO out2(s_lab, m)
  97586        RETURN
  97599      }
  97605   
  97607      CASE s_loop:
  97624        context, comline := x, h2!x
  97658        destlabel(s_loop)
  97682        IF looplab>0 DO out2(s_jump, looplab)
  97726        RETURN
  97739  
  97740      CASE s_break:
  97758        context, comline := x, h2!x
  97792        destlabel(s_break)
  97817        IF breaklab=-1 DO { out1(s_rtrn); RETURN }
  97866        IF breaklab> 0 DO out2(s_jump, breaklab)
  97913        RETURN
  97926   
  97928      CASE s_return:
  97947        context, comline := x, h2!x
  97981        out1(s_rtrn)
  98000        RETURN
  98013   
  98015      CASE s_skip:  // MR 05/4/06
  98047        trnext(next)
  98066        RETURN
  98079  
  98080      CASE s_finish:
  98099        context, comline := x, h2!x
  98133        out1(s_finish)
  98154        RETURN
  98167   
  98169      CASE s_resultis:
  98190        context, comline := x, h3!x
  98224        IF resultlab=-1 DO { fnbody(h2!x, FALSE); RETURN }
  98281        UNLESS resultlab>0 DO trnerr("RESULTIS out of context")
  98343        load(h2!x, FALSE)
  98367        out2(s_res, resultlab)
  98396        ssp := ssp - 1
  98417        RETURN
  98430   
  98432      CASE s_while: sw := TRUE
  98461      CASE s_until:
  98479      { LET l, m = nextlab(), next
  98512        LET bl, ll = breaklab, looplab
  98549        context, comline := x, h4!x
  98583        breaklab, looplab := next, 0
  98618        IF next<=0 DO m := nextlab()
  98653        IF next =0 DO breaklab := m
  98687        jumpcond(h2!x, ~sw, m)
  98716        out2(s_lab, l)
  98737        trans(h3!x, 0)
  98758        UNLESS looplab=0 DO out2(s_lab, looplab)
  98805        context, comline := x, h4!x
  98839        jumpcond(h2!x, sw, l)
  98867        IF next<=0 DO out2(s_lab, m)
  98902        trnext(next)
  98921        breaklab, looplab := bl, ll
  98955        RETURN
  98968      }
  98974   
  98976      CASE s_repeatwhile: sw := TRUE
  99011      CASE s_repeatuntil:
  99035      { LET l, bl, ll = nextlab(), breaklab, looplab
  99086        context, comline := x, h4!x
  99120        breaklab, looplab := next, 0
  99155        out2(s_lab, l)
  99176        trans(h2!x, 0)
  99197        UNLESS looplab=0 DO out2(s_lab, looplab)
  99244        context, comline := x, h4!x
  99278        jumpcond(h3!x, sw, l)
  99306  
  99307  //    UNLESS breaklab=0 DO out2(s_lab, breaklab)
  99356        IF next=0 & breaklab>0 DO out2(s_lab, breaklab)
  99410  
  99411        trnext(next)
  99430        breaklab, looplab := bl, ll
  99464        RETURN
  99477      }
  99483   
  99485      CASE s_repeat:
  99504      { LET bl, ll = breaklab, looplab
  99541        context, comline := x, h4!x
  99575        breaklab, looplab := next, nextlab()
  99618        out2(s_lab, looplab)
  99645  
  99646        trans(h2!x, looplab)
  99673  
  99674        IF next=0 & breaklab>0 DO out2(s_lab, breaklab)
  99728  
  99729        breaklab, looplab := bl, ll
  99763        RETURN
  99776      }
  99782   
  99784      CASE s_case:
  99801      { LET l, k, cl = nextlab(), ?, caselist
  99845        context, comline := x, h4!x
  99879        k := evalconst(h2!x, FALSE)
  99913        IF casecount<0 DO trnerr("CASE label out of context")
  99973        UNTIL cl=0 DO
  99993        { IF h2!cl=k DO trnerr("'CASE %n:' occurs twice", k)
 100052          cl := h1!cl
 100072        }
 100080        caselist := newblk(caselist, k, l)
 100121        casecount := casecount + 1
 100154        out2(s_lab, l)
 100175        trans(h3!x, next)
 100199        RETURN
 100212      }
 100218   
 100220      CASE s_default:
 100240        context, comline := x, h3!x
 100274        IF casecount<0 | defaultlab~=0 DO trnerr("Bad DEFAULT label")
 100342        defaultlab := nextlab()
 100372        out2(s_lab, defaultlab)
 100402        trans(h2!x, next)
 100426        RETURN
 100439   
 100441      CASE s_endcase:
 100461        context, comline := x, h2!x
 100495        destlabel(s_endcase)
 100522        IF endcaselab=-1 DO out1(s_rtrn)
 100561        // endcaselab is never equal to 0
 100601        IF endcaselab>0  DO out2(s_jump, endcaselab)
 100652        RETURN
 100665   
 100667      CASE s_switchon:
 100688        transswitch(x, next)
 100715        RETURN
 100728   
 100730      CASE s_for:
 100746        transfor(x, next)
 100770        RETURN
 100783   
 100785      CASE s_seq:
 100801        trans(h2!x, 0)
 100822        x := h3!x
 100838    }
 100842  } REPEAT
 100851  
 100852  AND destlabel(op) = VALOF SWITCHON op INTO
 100895  { DEFAULT: RESULTIS 0
 100917  
 100918    CASE s_loop:
 100933        IF looplab<0 DO trnerr("Illegal use of LOOP")
 100985        IF looplab=0 DO looplab := nextlab()
 101028        RESULTIS looplab
 101051  
 101052    CASE s_break:
 101068        IF breaklab=-2 DO trnerr("Illegal use of BREAK")
 101123        IF breaklab= 0 DO breaklab := nextlab()
 101169        RESULTIS breaklab
 101193  
 101194    CASE s_endcase:
 101212        IF endcaselab=-2 DO trnerr("Illegal use of ENDCASE")
 101271        // endcaselab is never equal to 0
 101311        RESULTIS endcaselab
 101337  }
 101339  
 101340  LET declnames(x) BE
 101360    // x is the definition(s) following LET, so the leading operator is
 101430    // one of s_vecdef, s_valdef, s_fndef, s_rtdef or s_and.
 101489    // This function adds names to the declaration vector.
 101546    UNLESS x=0 SWITCHON h1!x INTO
 101578   
 101580  { DEFAULT:        trnerr("Compiler error in Declnames")
 101636                    RETURN
 101661   
 101663    CASE s_vecdef: context, comline := x, h4!x
 101708                   IF h1!(h2!x)=s_flt DO
 101747                   { trnerr("Vector name must not have the FLT tag")
 101814                     h2!x := h2!(h2!x) // Remove the FLT tag
 101873                   }
 101892                   decldyn(h2!x)
 101923                   RETURN
 101947   
 101949    CASE s_valdef: context, comline := x, h4!x
 101994                   decldyn(h2!x)
 102025                   RETURN
 102049   
 102051    CASE s_rtdef:
 102067    CASE s_fndef:  context, comline := x, h6!x
 102112                   IF h1!(h2!x)=s_flt DO
 102151                   { trnerr("Function name must not have the FLT tag")
 102220                     h2!x := h2!(h2!x) // Remove the FLT tag
 102279                   }
 102298                   h5!x := nextlab()
 102333                   declstat(h2!x, h5!x)
 102371                   RETURN
 102395   
 102397    CASE s_and:    declnames(h2!x)
 102430                   declnames(h3!x)
 102463  }
 102465   
 102467  AND decldyn(x) BE UNLESS x=0 DO
 102499   
 102501  { // x is a list of name with possible FLT tags.
 102550    // They are added to the declaration vector with kind
 102606    // s_local or s_flocal.
 102632    LET k = s_local
 102650  
 102651    IF h1!x=s_flt DO
 102670    { k := s_flocal
 102688      x := h2!x
 102702    }
 102706  
 102707    IF h1!x=s_name  DO { addname(x, k, ssp)
 102749                         IF xrefing DO
 102786                           xref(x,
 102819                                (k=s_local -> "P:", "FP:"),
 102877                                 ssp, s_local)
 102922                         ssp := ssp + 1
 102960                         RETURN
 102990                       }
 103013   
 103015    IF h1!x=s_comma DO { decldyn(h2!x)
 103052                         decldyn(h3!x)
 103089                         RETURN
 103119                       }
 103142   
 103144    trnerr("Compiler error in Decldyn")
 103182  }
 103184   
 103186  AND declstat(x, lab) BE
 103210  { LET c = cellwithname(x)
 103236    LET fk = h2!c
 103252    LET k = fk & s_fltmask 
 103278    TEST k=s_global THEN { LET gn = h3!c
 103317                           gdeflist := newblk(gdeflist, gn, lab)
 103380                           gdefcount := gdefcount + 1
 103432                           addname(x, s_global, gn)
 103482                           IF xrefing DO
 103521                             xref(x,
 103556                                  (fk=s_fglobal -> "FG:", "G:"),
 103619                                  gn, h1!context)
 103667                           IF gdefsing DO writef("G%i3 = %s*n", gn, @h3!x)
 103740                         }
 103765                    ELSE { addname(x, s_label, lab)
 103815                           IF xrefing DO
 103854                             xref(x,
 103889                                  (fk=s_flocal -> "FF:", "F:"),
 103951                                  lab, h1!context)
 104000                         }
 104025  }
 104027   
 104029  AND decllabels(x) BE
 104050  { LET e = dvece
 104066    scanlabels(x)
 104082    checkdistinct(e)
 104101  }
 104103   
 104105  AND checkdistinct(p) BE
 104129  { LET lim = dvece - 3
 104151    FOR q = p TO lim-3 BY 3 DO
 104180    { LET n = h1!q
 104197      FOR c = q+3 TO lim BY 3 DO
 104228          IF h1!c=n DO trnerr("Name %s defined twice", @h3!n)
 104288    }
 104292  }
 104294   
 104296  AND addname(name, k, a) BE
 104323  { LET p = dvece + 3
 104343    IF p>dvect DO trnerr("More workspace needed")
 104391    h1!dvece, h2!dvece, h3!dvece := name, k, a
 104436    h2!name := dvece // Remember the declaration
 104483    dvece := p
 104496    //writef("addname: name cell at=%n %s k=%n a=%n*n", dvece-3, @h3!name, k, a)
 104575  }
 104577   
 104579  AND undeclare(e) BE 
 104600  { FOR t = e TO dvece-3 BY 3 DO
 104631    { LET name = h1!t
 104651      h2!name := 0   // Forget its declaration
 104696    }
 104700    dvece := e
 104713  }
 104715  
 104716  AND cellwithname(n) = VALOF
 104744  { // n is a name node not prefixed by FLT.
 104787    LET t = h2!n
 104802    IF t RESULTIS t  // It has been looked up before
 104853    t := dvece
 104866    t := t - 3 REPEATUNTIL h1!t=n | h1!t=0
 104907    h2!n := t  // Associate the name with declaration item
 104964    RESULTIS t
 104977  }
 104979   
 104981  AND scanlabels(x) BE UNLESS x=0 SWITCHON h1!x INTO
 105032   
 105034  { CASE s_colon:   context, comline := x, h5!x
 105080                    h4!x := nextlab()
 105116                    declstat(h2!x, h4!x)
 105155   
 105157    CASE s_if: CASE s_unless: CASE s_while: CASE s_until:
 105213    CASE s_switchon: CASE s_case:
 105245                    scanlabels(h3!x)
 105280                    RETURN
 105305   
 105307    CASE s_seq:     scanlabels(h3!x)
 105342   
 105344    CASE s_repeat: CASE s_repeatwhile: CASE s_repeatuntil:
 105401    CASE s_default: scanlabels(h2!x)
 105436                    RETURN
 105461   
 105463    CASE s_test:    scanlabels(h3!x)
 105498                    scanlabels(h4!x)
 105533    DEFAULT:        RETURN
 105558  }
 105560   
 105562  AND transdef(x) BE
 105581  { LET ctxt, ln = context, comline
 105615    transdyndefs(x)
 105633    context, comline := ctxt, ln
 105664    IF statdefs(x) DO { LET l, s= nextlab(), ssp
 105711                        out2(s_jump, l)
 105749                        transstatdefs(x)
 105788                        ssp := s
 105819                        out2(s_stack, ssp)
 105860                        out2(s_lab, l)
 105897                      }
 105919    context, comline := ctxt, ln
 105950  }
 105952   
 105954   
 105956  AND transdyndefs(x) BE SWITCHON h1!x INTO
 105998  { CASE s_and:    transdyndefs(h2!x)
 106034                   transdyndefs(h3!x)
 106070                   RETURN
 106094   
 106096    CASE s_vecdef: context, comline := x, h4!x
 106141                   out2(s_llp, vecssp)
 106178                   ssp := ssp + 1
 106210                   vecssp := vecssp + 1 + evalconst(h3!x, FALSE)
 106273                   RETURN
 106297   
 106299    CASE s_valdef: // Compile initialisation code for declaration
 106363                   // N = E  or  FLT N = E
 106404                   context, comline := h3!x, h4!x
 106452                   load(h3!x, h1!(h2!x)=s_flt -> TRUE, FALSE)
 106512    DEFAULT:       RETURN
 106536  }
 106538   
 106540  AND transstatdefs(x) BE SWITCHON h1!x INTO
 106583  { CASE s_and:  transstatdefs(h2!x)
 106618                 transstatdefs(h3!x)
 106653                 RETURN
 106675   
 106677    CASE s_fndef:
 106693    CASE s_rtdef:
 106709               { LET e, p = dvece, dvecp
 106748                 AND oldpn = procname
 106784                 AND bl, ll = breaklab,  looplab
 106831                 AND rl, el = resultlab, endcaselab
 106881                 AND cl, cc = caselist,  casecount
 106930                 AND name = h2!x // The FLT tag if any will have been 
 106999                                 // removed by declstat.
 107054                 breaklab,  looplab    := -2, -2
 107101                 resultlab, endcaselab := -2, -2
 107148                 caselist,  casecount  :=  0, -1
 107195                 procname := name
 107227                 context, comline := x, h6!x
 107270                 out2(s_entry, h5!x)
 107305                 outstring(@h3!procname)
 107344                 ssp := savespacesize
 107380                 dvecp := dvece
 107410                 context, comline := x, h6!x
 107453                 decldyn(h3!x)    // Declare the formal parameters
 107518                 checkdistinct(e) // Check that they are distinct.
 107583                 context, comline := h4!x, h6!x
 107629                 decllabels(h4!x)
 107661                 out2(s_save, ssp)
 107694                 context, comline := h4!x, h6!x
 107740                 TEST h1!x=s_rtdef THEN trans(h4!x, -1)
 107794                                   ELSE fnbody(h4!x, FALSE)
 107852                 out1(s_endproc)
 107883   
 107885                 breaklab,  looplab    := bl, ll
 107932                 resultlab, endcaselab := rl, el
 107979                 caselist,  casecount  := cl, cc
 108026                 procname := oldpn
 108059                 dvecp := p
 108085                 undeclare(e)
 108113               }
 108128   
 108130    DEFAULT:     RETURN
 108152  }
 108154   
 108156  AND statdefs(x) = h1!x=s_fndef | h1!x=s_rtdef -> TRUE,
 108211                    h1!x ~= s_and               -> FALSE,
 108267                    statdefs(h2!x)              -> TRUE,
 108322                    statdefs(h3!x)
 108355   
 108357   
 108359  LET jumpcond(x, b, l) BE
 108384  { LET sw = b
 108397  
 108398    SWITCHON h1!x INTO
 108419    { CASE s_false:  b := NOT b
 108449      CASE s_true:   IF b DO out2(s_jump, l)
 108492                     RETURN
 108518   
 108520      CASE s_not:    jumpcond(h2!x, NOT b, l)
 108564                     RETURN
 108590   
 108592      CASE s_logand: sw := NOT sw
 108624      CASE s_logor:  TEST sw THEN { jumpcond(h2!x, b, l)
 108679                                    jumpcond(h3!x, b, l)
 108734                                    RETURN
 108775                                  }
 108809   
 108811                             ELSE { LET m = nextlab()
 108863                                    jumpcond(h2!x, NOT b, m)
 108922                                    jumpcond(h3!x, b, l)
 108977                                    out2(s_lab, m)
 109026                                    RETURN
 109067                                  }
 109101   
 109103      DEFAULT:       load(x, FALSE)
 109137                     out2(b -> s_jt, s_jf, l)
 109181                     ssp := ssp - 1
 109215                     RETURN
 109241    }
 109245  }
 109247   
 109249  AND transswitch(x, next) BE
 109277  { LET cl, cc = caselist, casecount 
 109313    LET dl, el = defaultlab, endcaselab
 109351    LET l, dlab = nextlab(), ?
 109380    caselist, casecount, defaultlab := 0, 0, 0
 109425    endcaselab := next=0 -> nextlab(), next
 109467   
 109469    context, comline := x, h4!x
 109499  
 109500    load(h2!x, FALSE)  // Evaluate the switch expression
 109555  
 109556    out2(s_res, l) // Make a jump to the end of the switch
 109613                   // with the switch expression in<res>
 109668    ssp := ssp-1
 109683  
 109684    // Compile the switch body collecting the case label data
 109744    trans(h3!x, endcaselab)
 109770   
 109772    context, comline := x, h4!x
 109802    out2(s_lab, l) // The switch value is on the top of the stack
 109866    out2(s_rstack, ssp) // Load <res> onto the top of the stack
 109928    ssp := ssp+1
 109943  
 109944    dlab := defaultlab>0 -> defaultlab,
 109982            endcaselab>0 -> endcaselab,
 110020            nextlab()
 110040  
 110041    // The switch expression value is on the top of the stack
 110101    out2(s_switchon, casecount); out1(dlab) 
 110144    UNTIL caselist=0 DO { out2(h2!caselist, h3!caselist)
 110199                          caselist := h1!caselist
 110247                        }
 110271    ssp := ssp - 1
 110288  
 110289    IF next=0                DO   out2(s_lab, endcaselab)
 110345    IF next<0 & defaultlab=0 DO { out2(s_lab, dlab)
 110395                                  out1(s_rtrn)
 110440                                }
 110472  
 110473    defaultlab, endcaselab := dl, el
 110508    caselist,   casecount  := cl, cc
 110543  }
 110545   
 110547  AND transfor(x, next) BE
 110572  { LET e, m, blab = dvece, nextlab(), 0
 110611    LET bl, ll = breaklab, looplab
 110644    LET cc = casecount
 110665    LET k, n, step = 0, 0, 1
 110692    LET s = ssp
 110706    LET name = h2!x
 110724  
 110725    casecount := -1  // Disallow CASE and DEFAULT labels.   
 110784    breaklab, looplab := next, 0
 110815     
 110819    context, comline := x, h7!x
 110849   
 110851    IF h1!name=s_flt DO
 110873    { trnerr("FOR loop control variable must not have the FLT tag")
 110939      name := h2!name
 110959      h2!x := name
 110976    }
 110980  
 110981    addname(name, s_local, s)
 111009    load(h3!x, FALSE)       // The initial value
 111056   
 111058    // Set k, n to load the end limit
 111094    TEST h1!(h4!x)=s_number THEN   k, n := s_ln, h2!(h4!x)
 111151                            ELSE { k, n := s_lp, ssp
 111202                                   load(h4!x, FALSE)
 111253                                 }
 111286   
 111288    IF h5!x DO step := evalconst(h5!x, FALSE)
 111332   
 111334    out1(s_store)
 111350     
 111354    TEST k=s_ln & h1!(h3!x)=s_number  // check for constant limits 
 111420    THEN { LET initval = h2!(h3!x)
 111453           IF step>=0 & initval>n | step<0 & initval<n DO
 111509           { TEST next<0
 111532             THEN out1(s_rtrn)
 111561             ELSE TEST next>0
 111589                  THEN out2(s_jump, next)
 111629                  ELSE { blab := breaklab>0 -> breaklab, nextlab()
 111694                         out2(s_jump, blab)
 111736                       }
 111759           }
 111770         }
 111779    ELSE { IF next<=0 DO blab := nextlab()
 111820           out2(s_lp, s)
 111843           out2(k, n)
 111863           out1(step>=0 -> s_gr, s_ls)
 111900           out2(s_jt, next>0 -> next, blab)
 111942         }
 111951  
 111952    IF breaklab=0 & blab>0 DO breaklab := blab
 111997     
 112001    context, comline := x, h7!x
 112031    decllabels(h6!x)
 112050    context, comline := x, h7!x
 112080    out2(s_lab, m)
 112097    trans(h6!x, 0)
 112114    UNLESS looplab=0 DO out2(s_lab, looplab)
 112157    out2(s_lp, s); out2(s_ln, step); out1(s_add); out2(s_sp, s)
 112219    out2(s_lp,s); out2(k,n); out1(step>=0 -> s_le, s_ge)
 112274    out2(s_jt, m)
 112290   
 112292    IF next<=0 TEST blab>0 
 112318               THEN                  out2(s_lab, blab)
 112371               ELSE IF breaklab>0 DO out2(s_lab, breaklab)
 112428    trnext(next)
 112443    casecount := cc
 112461    breaklab, looplab, ssp := bl, ll, s
 112499    out2(s_stack, ssp)
 112520    undeclare(e)
 112535  }
 112537  
 112538  LET isflt(x) = x=0 -> FALSE, VALOF
 112573  { // Return TRUE if expression x is an fnumber, a name declared
 112637    // with the FLT tag or has a leading operator such as #+ or #-
 112702    // that returns a floating point value. Remember the operators
 112767    // such as + and - are converted to #+ and #- if they have
 112828    // floating point operands.
 112858    SWITCHON h1!x INTO
 112879    { DEFAULT:  RESULTIS FALSE
 112908  
 112909      CASE s_name: { LET c = cellwithname(x)
 112952                     IF (h2!c & s_fltbit)=0 RESULTIS FALSE
 113009                     RESULTIS TRUE
 113042                   }
 113061  
 113062      CASE s_float: CASE s_fabs:
 113093      CASE s_fpos:  CASE s_fneg:
 113124      CASE s_fadd:  CASE s_fsub:
 113155      CASE s_fmul:  CASE s_fdiv: CASE s_fmod:
 113199      CASE s_fcond:
 113217      CASE s_fnum:  RESULTIS TRUE
 113249  
 113250      CASE s_neg: CASE s_abs:
 113278        RESULTIS isflt(h2!x)
 113305  
 113306      CASE s_add: CASE s_sub:
 113334      CASE s_mul: CASE s_div: CASE s_mod:
 113374        IF isflt(h2!x) | isflt(h3!x) RESULTIS TRUE
 113423        RESULTIS FALSE
 113444  
 113445      CASE s_cond:
 113462        IF isflt(h3!x) | isflt(h4!x) RESULTIS TRUE
 113511        RESULTIS FALSE
 113532    }    
 113540  }
 113542   
 113544  LET load(x, ff) BE
 113563  { // Translate expression x into Ocode.
 113603    // If ff=TRUE the expression in an FLT context and will
 113661    // convert, for example, + and - to #+ and #-.
 113710    LET op = h1!x
 113726  
 113727    IF isconst(x) DO
 113746    { out2(s_ln, evalconst(x, ff | isflt(x)))
 113790      ssp := ssp + 1
 113809      RETURN
 113820    }
 113824   
 113826    SWITCHON op INTO
 113845    { DEFAULT:
 113858             trnerr("Compiler error in Load")
 113902             out2(s_ln, 0)
 113927             ssp := ssp + 1
 113953             RETURN
 113971   
 113973      CASE s_of:
 113988           { LET slct = evalconst(h2!x, FALSE) // Inserted 11/7/01
 114053             LET len = slct>>24
 114083             LET sh  = slct>>16 & 255
 114119             LET offset = slct & #xFFFF
 114157             load(h3!x, FALSE)
 114186             IF offset DO
 114210             { out2(s_ln, offset)
 114242               out1(s_add)
 114267             }
 114280  
 114281             // Optimise accessing a complete word.
 114331             IF sh=0 & (len=0 | len=wordbitlen) DO
 114380             { out1(s_rv) // The source field is a complete word
 114443               RETURN
 114463             }
 114476  
 114477             // Compile (SLCT len:sh:0)(E+offset)
 114525             TEST noselst
 114549             THEN { // Old version not using SELLD
 114598                    out1(s_rv)
 114627                    IF sh DO
 114654                    { out2(s_ln, sh)
 114689                      out1(s_rshift)
 114724                    }
 114744                    IF len>0 & (len+sh~=wordbitlen) DO
 114797                    { // Applying a mask is necessary
 114849                      LET mask = (1<<len)-1
 114891                      out2(s_ln, mask)
 114928                      out1(s_logand)
 114963                    }
 114983                  }
 115001             ELSE { // New version using SELLD
 115046                    out3(s_selld, len, sh)
 115087                  }
 115105             RETURN
 115123           }
 115134  
 115135      CASE s_div: CASE s_mod: CASE s_sub:
 115175           // Convert to floating point if in FLT mode or
 115231           // has a floating point operand.
 115273           IF ff | isflt(x) DO
 115302           { // Convert to floating point operators.
 115353             h1!x := cv2flt(op)
 115383             load(x, TRUE)
 115408             RETURN
 115426           }
 115437           load(h2!x, FALSE)
 115464           load(h3!x, FALSE)
 115491           out1(op)
 115509           ssp := ssp - 1
 115533           RETURN
 115549                        
 115572      CASE s_fdiv: CASE s_fmod: CASE s_fsub:
 115615           load(h2!x, TRUE)
 115641           load(h3!x, TRUE)
 115667           out1(op)
 115685           ssp := ssp - 1
 115709           RETURN
 115725  
 115726      CASE s_ls: CASE s_gr: CASE s_le: CASE s_ge:
 115774           // Only convert to floating point if they have
 115830           // a floating point operand.
 115868           IF isflt(h2!x) | isflt(h3!x) DO
 115909           { // Convert to floating point operators.
 115960             h1!x := cv2flt(op)
 115990             load(x, TRUE)
 116015             RETURN
 116033           }
 116044           load(h2!x, FALSE)
 116071           load(h3!x, FALSE)
 116098           out1(op)
 116116           ssp := ssp - 1
 116140           RETURN
 116156                        
 116179  
 116180      CASE s_fls: CASE s_fgr: CASE s_fle: CASE s_fge:
 116232           load(h2!x, TRUE)
 116258           load(h3!x, TRUE)
 116284           out1(op)
 116302           ssp := ssp - 1
 116326           RETURN
 116342   
 116344      CASE s_byteap:
 116363           load(h2!x, FALSE)
 116390           load(h3!x, FALSE)
 116417           out1(s_getbyte)    // Compiling: E1%E2
 116465           ssp := ssp - 1
 116489           RETURN
 116505  
 116506      CASE s_lshift: CASE s_rshift:
 116540           load(h2!x, FALSE)  // Compiling: E1<<E2  or  E1>>E2
 116601           UNLESS iszero(h3!x,FALSE) DO
 116639           { load(h3!x, FALSE)
 116668             out1(op)
 116688             ssp := ssp - 1
 116714           }
 116725           RETURN
 116741   
 116743      CASE s_eq: CASE s_ne:
 116769           // Relational operators are only converted if they
 116829           // have floating point operands.
 116871           IF isflt(h2!x) | isflt(h3!x) DO
 116912           { // Convert to floating point.
 116953             h1!x := cv2flt(op)
 116983             load(x, TRUE)
 117008             RETURN
 117026           }
 117037           GOTO intsymmetric
 117064  
 117065      CASE s_mul: CASE s_add:
 117093            // Convert to floating point if in FLT mode or
 117150            // has a floating point operand.
 117193           IF ff | isflt(x) DO
 117222           { h1!x := cv2flt(op)
 117252             load(x, TRUE)
 117277             RETURN
 117295           }
 117306           // Fall through
 117331  
 117332      CASE s_vecap:
 117350      CASE s_logand: CASE s_logor: CASE s_eqv: CASE s_xor:
 117407  intsymmetric:
 117421         // Symmetric non FLT dyadic operators.
 117467         { LET a, b = h2!x, h3!x
 117498           TEST h1!a=s_name   |
 117528                h1!a=s_number |
 117558                h1!a=s_fnum THEN { load(b, FALSE); load(a, FALSE) }
 117624                            ELSE { load(a, FALSE); load(b, FALSE) }
 117690           TEST op=s_vecap THEN out2(s_add, s_rv)
 117738                           ELSE out1(op)
 117777           ssp := ssp - 1
 117801           RETURN
 117817         }
 117826   
 117828      CASE s_fmul: CASE s_fadd: CASE s_feq: CASE s_fne:
 117882         { LET a, b = h2!x, h3!x
 117913           TEST h1!a=s_name   |
 117943                h1!a=s_number |
 117973                h1!a=s_fnum THEN { load(b, TRUE); load(a, TRUE) }
 118037                            ELSE { load(a, TRUE); load(b, TRUE) }
 118101           out1(op)
 118119           ssp := ssp - 1
 118143           RETURN
 118159         }
 118168   
 118170      CASE s_neg: CASE s_abs:
 118198         IF ff | isflt(x) DO
 118225         { h1!x := cv2flt(op)
 118253           load(x, TRUE)
 118276           RETURN
 118292        }
 118300        load(h2!x, FALSE)
 118324        out1(op)
 118339        RETURN
 118352  
 118353      CASE s_fneg: CASE s_fabs:CASE s_fix:
 118394        load(h2!x, TRUE)
 118417        out1(op)
 118432        RETURN
 118445   
 118447      CASE s_float: CASE s_not: CASE s_rv:
 118488        load(h2!x, FALSE)
 118512        out1(op)
 118527        RETURN
 118540   
 118542      CASE s_true: CASE s_false: CASE s_query:
 118587         out1(op)
 118603         ssp := ssp + 1
 118625         RETURN
 118639   
 118641      CASE s_lv:
 118656         loadlv(h2!x)
 118676         RETURN
 118690   
 118692      CASE s_number:
 118711  sawritef("number %n  ff=%n*n", h2!x, ff)
 118752         IF ff DO
 118768         { // Convert the integer constant to floating point
 118827           h1!x := s_fnum
 118851           h2!x := sys(Sys_flt, fl_mk, h2!x, 0)
 118897  sawritef("number converted to fnumber %13e*n", h2!x)
 118950         }
 118959         // Fall through
 118982      CASE s_fnum:
 118999         out2(s_ln, h2!x)
 119023         ssp := ssp + 1
 119045         RETURN
 119059   
 119061      CASE s_string:
 119080         out1(s_lstr)
 119100         outstring(@ h2!x)
 119125         ssp := ssp + 1
 119147         RETURN
 119161   
 119163      CASE s_name:
 119180         transname(x, s_lp, s_lg, s_ll, s_lf, s_ln)
 119230         ssp := ssp + 1
 119252         RETURN
 119266   
 119268      CASE s_valof:
 119286       { LET e, rl, cc = dvece, resultlab, casecount
 119337         casecount := -1 // Disallow CASE & DEFAULT labels
 119394         resultlab := nextlab()
 119424         decllabels(h2!x)
 119448         trans(h2!x, 0)
 119470         out2(s_lab, resultlab)
 119500         out2(s_rstack, ssp)
 119527         ssp := ssp + 1
 119549         resultlab, casecount := rl, cc
 119587         undeclare(e)
 119607         RETURN
 119621       }
 119628   
 119630      CASE s_fnap:
 119647       { LET s = ssp
 119666         ssp := ssp + savespacesize
 119700         out2(s_stack, ssp)
 119726         loadlist(h3!x) // Load arguments in non FLT mode
 119782         load(h2!x, FALSE)
 119807         out2(s_fnap, s)
 119830         ssp := s + 1
 119850         RETURN
 119864       }
 119871  
 119872      CASE s_fcond:
 119890         ff := TRUE
 119908         GOTO cond
 119925  
 119926      CASE s_cond:
 119943         IF ff | isflt(x) DO
 119970         { h1!x := s_fcond
 119995           load(x, TRUE)
 120018           RETURN
 120034         }
 120043  cond:
 120049       { LET l, m = nextlab(), nextlab()
 120088         LET s = ssp
 120107         jumpcond(h2!x, FALSE, m)
 120139         load(h3!x, ff)
 120161         out2(s_res,l)
 120182         ssp := s; out2(s_stack, ssp)
 120218         out2(s_lab, m)
 120240         load(h4!x, ff)
 120262         out2(s_res,l)
 120283         out2(s_lab, l)
 120305         out2(s_rstack,s)
 120329         RETURN
 120343       }
 120350   
 120352      CASE s_table:
 120370       { LET m = nextlab()
 120395         out2(s_datalab, m)
 120421         x := h2!x
 120438         WHILE h1!x=s_comma DO
 120467         { out2(s_itemn, evalconst(h2!x, FALSE))
 120514           x := h3!x
 120533         }
 120542         out2(s_itemn, evalconst(x, FALSE))
 120584         out2(s_lll, m)
 120606         ssp := ssp + 1
 120628         RETURN
 120642       }
 120649    }
 120653  }
 120655  
 120656  AND fnbody(x, ff) BE SWITCHON h1!x INTO
 120696  { DEFAULT:         load(x, ff)
 120727                     out1(s_fnrn)
 120759                     ssp := ssp - 1
 120793                     RETURN
 120819                     
 120839    CASE s_valof: { LET e, rl, cc = dvece, resultlab, casecount
 120901                    casecount := -1 // Disallow CASE & DEFAULT labels
 120969                    resultlab := -1
 121003                    decllabels(h2!x)
 121038                    trans(h2!x, -1)
 121072                    resultlab, casecount := rl, cc
 121121                    undeclare(e)
 121152                    RETURN
 121177                  }
 121195  
 121196    CASE s_fcond: { LET l = nextlab()
 121232                    jumpcond(h2!x, FALSE, l)
 121275                    fnbody(h3!x, TRUE)
 121312                    out2(s_lab, l)
 121345                    fnbody(h4!x, TRUE)
 121382                    RETURN
 121407                  }
 121425  
 121426    CASE s_cond:  { LET l = nextlab()
 121462                    IF ff | isflt(x) DO
 121500                    { h1!x := s_fcond    // Replace -> by #->
 121560                      fnbody(x, TRUE)
 121596                      RETURN
 121623                    }
 121643                    jumpcond(h2!x, FALSE, l)
 121686                    fnbody(h3!x, ff)
 121721                    out2(s_lab, l)
 121754                    fnbody(h4!x, ff)
 121789                  }
 121807  }
 121809   
 121811   
 121813  AND loadlv(x) BE
 121830  { UNLESS x=0 SWITCHON h1!x INTO
 121862    { DEFAULT:         ENDCASE
 121891   
 121893      CASE s_name:     transname(x, s_llp, s_llg, s_lll, 0, 0)
 121954                       ssp := ssp + 1
 121990                       RETURN
 122018   
 122020      CASE s_rv:       load(h2!x, FALSE)
 122059                       RETURN
 122087   
 122089      CASE s_vecap: { LET a, b = h2!x, h3!x
 122131                      TEST h1!a=s_name   |
 122172                           h1!a=s_number |
 122213                           h1!a=s_fnum THEN { load(b, FALSE); load(a, FALSE) }
 122290                                       ELSE { load(a, FALSE); load(b, FALSE) }
 122367                      out1(s_add)
 122399                      ssp := ssp - 1
 122434                      RETURN
 122461                    }
 122481    }
 122485  
 122486    trnerr("Ltype expression needed")
 122522    out2(s_ln, 0)
 122538    ssp := ssp + 1
 122555  }
 122557   
 122559  AND loadlist(x) BE
 122578  { // Load function or routine arguments
 122618    UNLESS x=0 TEST h1!x=s_comma
 122649               THEN { loadlist(h2!x); loadlist(h3!x) }
 122702               ELSE load(x, FALSE)
 122735  }
 122737  
 122738  // The conversion function are:
 122770  //    op2sfop   convert an expression op to a selst sfop
 122827  //    assop2op  convert op:= to op
 122862  //    cv2flt    convert an integer op or assignment op
 122917  //              to the floating point version.
 122964  
 122965  AND op2sfop(op) = VALOF SWITCHON op INTO
 123006  { DEFAULT:       sawritef("Syserr in op2sfop op=%s not in switch*n",
 123075                            opname(op))
 123113                   RESULTIS op
 123142  
 123143    CASE s_none:   RESULTIS sf_none
 123177  
 123178    CASE s_vecap:  RESULTIS sf_vecap
 123213  
 123214    CASE s_mul:    RESULTIS sf_mul
 123247    CASE s_div:    RESULTIS sf_div
 123280    CASE s_mod:    RESULTIS sf_mod
 123313    CASE s_add:    RESULTIS sf_add
 123346    CASE s_sub:    RESULTIS sf_sub
 123379  
 123380    CASE s_fmul:   RESULTIS sf_fmul
 123414    CASE s_fdiv:   RESULTIS sf_fdiv
 123448    CASE s_fmod:   RESULTIS sf_fmod
 123482    CASE s_fadd:   RESULTIS sf_fadd
 123516    CASE s_fsub:   RESULTIS sf_fsub
 123550  
 123551    CASE s_lshift: RESULTIS sf_lshift
 123587    CASE s_rshift: RESULTIS sf_rshift
 123623    CASE s_logand: RESULTIS sf_logand
 123659    CASE s_logor:  RESULTIS sf_logor
 123694    CASE s_eqv:    RESULTIS sf_eqv
 123727    CASE s_xor:    RESULTIS sf_xor
 123760  
 123761  }
 123763  
 123764  AND assop2op(op) = VALOF SWITCHON op INTO
 123806  { DEFAULT:       sawritef("Syserr in assop2op unknown op=%s*n",
 123870                            opname(op))
 123908                   RESULTIS op
 123937  
 123938  //  CASE  0:       RESULTIS 0
 123968  
 123969    CASE s_assfmul:   RESULTIS s_fmul
 124005    CASE s_assfdiv:   RESULTIS s_fdiv
 124041    CASE s_assfmod:   RESULTIS s_fmod
 124077    CASE s_assfadd:   RESULTIS s_fadd
 124113    CASE s_assfsub:   RESULTIS s_fsub
 124149  
 124150    CASE s_assmul:    RESULTIS s_mul
 124185    CASE s_assdiv:    RESULTIS s_div
 124220    CASE s_assmod:    RESULTIS s_mod
 124255    CASE s_assadd:    RESULTIS s_add
 124290    CASE s_asssub:    RESULTIS s_sub
 124325  
 124326    CASE s_assvecap:  RESULTIS s_vecap
 124363    CASE s_asslshift: RESULTIS s_lshift
 124401    CASE s_assrshift: RESULTIS s_rshift
 124439    CASE s_asslogand: RESULTIS s_logand
 124477    CASE s_asslogor:  RESULTIS s_logor
 124514    CASE s_asseqv:    RESULTIS s_eqv
 124549    CASE s_assxor:    RESULTIS s_xor
 124584  
 124585    CASE s_fass:
 124600    CASE s_ass:       RESULTIS s_none
 124636  }
 124638  
 124639  AND cv2flt(op) = VALOF SWITCHON op INTO
 124679  { DEFAULT:       sawritef("Syserr in cv2flt op=%s not in switch*n",
 124747                            opname(op))
 124785                   RESULTIS op
 124814  
 124815    // Expression operators
 124841    CASE s_neg:    RESULTIS s_fneg
 124874    CASE s_abs:    RESULTIS s_fabs
 124907    CASE s_number: RESULTIS s_fnum
 124940    CASE s_mul:    RESULTIS s_fmul
 124973    CASE s_div:    RESULTIS s_fdiv
 125006    CASE s_mod:    RESULTIS s_fmod
 125039    CASE s_add:    RESULTIS s_fadd
 125072    CASE s_sub:    RESULTIS s_fsub
 125105    CASE s_eq:     RESULTIS s_feq
 125137    CASE s_ne:     RESULTIS s_fne
 125169    CASE s_ls:     RESULTIS s_fls
 125201    CASE s_gr:     RESULTIS s_fgr
 125233    CASE s_le:     RESULTIS s_fle
 125265    CASE s_ge:     RESULTIS s_fge
 125297    CASE s_cond:   RESULTIS s_fcond
 125331  
 125332    // Assignment operators
 125358    CASE s_assmul: RESULTIS s_assfmul
 125394    CASE s_assdiv: RESULTIS s_assfdiv
 125430    CASE s_assmod: RESULTIS s_assfmod
 125466    CASE s_assadd: RESULTIS s_assfadd
 125502    CASE s_asssub: RESULTIS s_assfsub
 125538    CASE s_ass:    RESULTIS s_fass
 125571  }
 125573  
 125574  LET isconst(x) = VALOF
 125597  { // Return TRUE if the expression x has a value that can
 125655    // be determined at compile time. These are manifest names,
 125717    // integer or floating point constants, the SLCT construct,
 125779    // TRUE or FALSE, and any expression whose operands are constants
 125847    // other than rv, vecap or byteap expressions.
 125896  
 125897    IF x=0 RESULTIS FALSE
 125921   
 125923    SWITCHON h1!x INTO
 125944    { CASE s_name:
 125961          { LET c = cellwithname(x)
 125995            LET k = h2!c & s_fltmask
 126030            RESULTIS k=s_manifest -> TRUE, FALSE
 126077          }
 126087  
 126088      CASE s_fnum:
 126105      CASE s_number:
 126124      CASE s_slct:
 126141      CASE s_true:
 126158      CASE s_false:  RESULTIS TRUE
 126191   
 126193      CASE s_fneg:
 126210      CASE s_fabs:
 126227      CASE s_float:
 126245      CASE s_fix:
 126261      CASE s_neg:
 126277      CASE s_abs:
 126293      CASE s_not:    RESULTIS isconst(h2!x)
 126335         
 126343      CASE s_fmul:
 126360      CASE s_fdiv:
 126377      CASE s_fmod:
 126394      CASE s_fadd:
 126411      CASE s_fsub:
 126428      CASE s_feq:
 126444      CASE s_fne:
 126460      CASE s_fls:
 126476      CASE s_fgr:
 126492      CASE s_fle:
 126508      CASE s_fge:
 126524  
 126525      CASE s_mul:
 126541      CASE s_div:
 126557      CASE s_mod:
 126573      CASE s_add:
 126589      CASE s_sub:
 126605      CASE s_lshift:
 126624      CASE s_rshift:
 126643      CASE s_logor:
 126661      CASE s_logand:
 126680      CASE s_eqv:
 126696      CASE s_xor:
 126712      CASE s_eq:
 126727      CASE s_ne:
 126742      CASE s_ls:
 126757      CASE s_gr:
 126772      CASE s_le:
 126787      CASE s_ge:
 126802                     UNLESS isconst(h2!x) RESULTIS FALSE
 126857                     RESULTIS isconst(h3!x)
 126899  
 126900      CASE s_fcond:
 126918      CASE s_cond:   UNLESS isconst(h2!x) RESULTIS FALSE
 126973                     UNLESS isconst(h3!x) RESULTIS FALSE
 127028                     RESULTIS isconst(h4!x)
 127070  
 127071      DEFAULT:       RESULTIS FALSE
 127105  
 127106    }
 127110  }
 127112  
 127113  LET iszero(x, ff) = isconst(x) & evalconst(x, ff)=0 -> TRUE, FALSE
 127180  
 127181  LET evalconst(x, ff) = VALOF
 127210  { // If ff=TRUE the expression x is to be evaluated in
 127265    // an FLT context, causing integer expression operators
 127323    // to be automatically converted to their floating
 127376    // point versions. Integer constants are also converted
 127434    // to floating point.
 127458  
 127459    LET op, a, b = 0, 0, 0
 127484  
 127485    IF x=0 DO { trnerr("Compiler error in Evalconst")
 127537                RESULTIS 0
 127562              }
 127576  
 127577    IF isflt(x) DO ff := TRUE
 127605   
 127607    op := h1!x
 127620  //sawritef("evalconst: op=%s ff=%n*n", opname(op), ff)
 127675  
 127676    SWITCHON op INTO
 127695    { CASE s_name: { LET c = cellwithname(x)
 127738                     LET k = h2!c
 127770                     LET a = h3!c
 127802                     IF (k & s_fltmask)=s_manifest DO
 127854                     { IF xrefing DO
 127889                         xref(x,
 127920                              (k=s_manifest -> "M:", "FM:"),
 127979                              a, s_const)
 128019                       RESULTIS a
 128051                     }
 128072                     TEST k
 128098                     THEN trnerr("%s must be a MANIFEST constant", @h3!x)
 128170                     ELSE trnerr("Name '%s' is not declared", @h3!x)
 128237                     RESULTIS 0
 128267                   }
 128286   
 128288      CASE s_number: UNLESS ff RESULTIS h2!x
 128331                     // Convert from integer to floating point.
 128393                     h1!x := s_fnum
 128427                     h2!x := sys(Sys_flt, fl_mk, h2!x, 0)
 128483  
 128484      CASE s_fnum:   RESULTIS h2!x
 128517  
 128518      CASE s_true:   RESULTIS TRUE
 128551      CASE s_false:  RESULTIS FALSE
 128585      CASE s_query:  RESULTIS 0
 128615   
 128617      CASE s_slct: { LET len, sh, offset = 0, 0, 0     // Inserted 11/7/01
 128690                     IF h2!x DO len    := evalconst(h2!x, FALSE)
 128753                     IF h3!x DO sh     := evalconst(h3!x, FALSE)
 128816                     IF h4!x DO offset := evalconst(h4!x, FALSE)
 128879                     UNLESS 0<=len<=255 & 0<=sh<=255 & 0<=offset<=#xFFFF DO
 128953                         trnerr("A field too large in a SLCT expression")
 129025                     RESULTIS len<<24 | sh<<16 | offset
 129079                   }
 129098  
 129099      CASE s_fneg:
 129116      CASE s_fabs:
 129133      CASE s_fix:    floatingchk()
 129166                     a := evalconst(h2!x, TRUE)
 129212                     ENDCASE
 129239  
 129240      CASE s_neg:
 129256      CASE s_abs:    IF ff | isflt(x) DO 
 129296                     { h1!x := cv2flt(op)
 129336                       RESULTIS evalconst(x, TRUE)
 129385                     }
 129406                     a := evalconst(h2!x, FALSE)
 129453                     ENDCASE
 129480  
 129481      CASE s_not:       
 129504      CASE s_float:  a := evalconst(h2!x, FALSE)
 129551                     ENDCASE
 129578  
 129579      CASE s_fmul:
 129596      CASE s_fdiv:
 129613      CASE s_fmod:
 129630      CASE s_fadd:
 129647      CASE s_fsub:
 129664      CASE s_feq:
 129680      CASE s_fne:
 129696      CASE s_fls:
 129712      CASE s_fgr:
 129728      CASE s_fle:
 129744      CASE s_fge:  floatingchk()
 129775                   a, b := evalconst(h2!x, TRUE), evalconst(h3!x, TRUE)
 129845                   ENDCASE
 129870  
 129871      CASE s_mul:
 129887      CASE s_div:
 129903      CASE s_mod:
 129919      CASE s_add:
 129935      CASE s_sub:  IF ff | isflt(x) DO
 129972                   { // Convert to floating point.
 130021                     h1!x := cv2flt(op)
 130059                     RESULTIS evalconst(x, TRUE)
 130106                   }
 130125                   a, b := evalconst(h2!x, FALSE), evalconst(h3!x, FALSE)
 130197                   ENDCASE
 130222  
 130223      CASE s_eq:
 130238      CASE s_ne:
 130253      CASE s_ls:
 130268      CASE s_gr:
 130283      CASE s_le:
 130298      CASE s_ge:   // Only convert to floating point if there is
 130361                   // a floating point operand.
 130407                   IF isflt(h2!x) | isflt(h3!x) DO
 130456                   { // Convert to floating point.
 130505                     h1!x := cv2flt(op)
 130543                     RESULTIS evalconst(x, TRUE)
 130590                   }
 130609                   a, b := evalconst(h2!x, FALSE), evalconst(h3!x, FALSE)
 130681                   ENDCASE
 130706  
 130707  
 130708      CASE s_lshift:
 130727      CASE s_rshift:
 130746      CASE s_logor:
 130764      CASE s_logand:
 130783      CASE s_eqv:
 130799      CASE s_xor:    a, b := evalconst(h2!x, FALSE), evalconst(h3!x, FALSE)
 130873                     ENDCASE
 130900  
 130901      CASE s_fcond:  a, b := evalconst(h2!x, TRUE), evalconst(h3!x, TRUE)
 130973                     ENDCASE
 131000  
 131001      CASE s_cond:   IF ff | isflt(x) DO
 131040                     { // Convert to floating point.
 131091                       h1!x := s_fcond
 131128                       RESULTIS evalconst(x, TRUE)
 131177                     }
 131198                     a, b := evalconst(h2!x, FALSE), evalconst(h3!x, FALSE)
 131272                     ENDCASE
 131299  
 131300      DEFAULT:
 131313    }
 131317      
 131322    SWITCHON h1!x INTO
 131343    { CASE s_neg:    RESULTIS  -  a
 131377      CASE s_abs:    RESULTIS ABS a
 131411      CASE s_not:    RESULTIS NOT a
 131445         
 131453      CASE s_fneg:   RESULTIS sys(Sys_flt, fl_neg,   a)
 131507      CASE s_fabs:   RESULTIS sys(Sys_flt, fl_abs,   a)
 131561      CASE s_fix:    RESULTIS sys(Sys_flt, fl_fix,   a)
 131615      CASE s_float:  RESULTIS sys(Sys_flt, fl_float, a)
 131669         
 131677      CASE s_fmul:   RESULTIS sys(Sys_flt, fl_mul, a,  b)
 131733      CASE s_fdiv:   RESULTIS sys(Sys_flt, fl_div, a,  b)
 131789      CASE s_fmod:   RESULTIS sys(Sys_flt, fl_mod, a,  b)
 131845      CASE s_fadd:   RESULTIS sys(Sys_flt, fl_add, a,  b)
 131901      CASE s_fsub:   RESULTIS sys(Sys_flt, fl_sub, a,  b)
 131957  
 131958      CASE s_feq:    RESULTIS sys(Sys_flt, fl_eq, a,  b)
 132013      CASE s_fne:    RESULTIS sys(Sys_flt, fl_ne, a,  b)
 132068      CASE s_fls:    RESULTIS sys(Sys_flt, fl_ls, a,  b)
 132123      CASE s_fgr:    RESULTIS sys(Sys_flt, fl_gr, a,  b)
 132178      CASE s_fle:    RESULTIS sys(Sys_flt, fl_le, a,  b)
 132233      CASE s_fge:    RESULTIS sys(Sys_flt, fl_ge, a,  b)
 132288  
 132289      CASE s_mul:    RESULTIS a   *   b
 132327      CASE s_add:    RESULTIS a   +   b
 132365      CASE s_sub:    RESULTIS a   -   b
 132403      CASE s_lshift: RESULTIS a   <<  b
 132441      CASE s_rshift: RESULTIS a   >>  b
 132479      CASE s_logor:  RESULTIS a   |   b
 132517      CASE s_logand: RESULTIS a   &   b
 132555      CASE s_eqv:    RESULTIS a  EQV  b
 132593      CASE s_xor:    RESULTIS a  XOR  b
 132631      CASE s_div:    RESULTIS b=0 -> 0, a  /  b
 132677      CASE s_mod:    RESULTIS b=0 -> 0, a MOD b
 132723      CASE s_eq:     RESULTIS a =  b
 132758      CASE s_ne:     RESULTIS a ~= b
 132793      CASE s_ls:     RESULTIS a <  b
 132828      CASE s_gr:     RESULTIS a >  b
 132863      CASE s_le:     RESULTIS a <= b
 132898      CASE s_ge:     RESULTIS a >= b
 132933  
 132934      CASE s_cond:   RESULTIS a -> b, evalconst(h4!x, FALSE)
 132993      CASE s_fcond:  RESULTIS a -> b, evalconst(h4!x, TRUE)
 133051     
 133055      DEFAULT:       ENDCASE
 133082    }
 133086  
 133087    trnerr("Error in manifest expression, op = %s", opname(h1!x))
 133151    RESULTIS 0
 133164  }
 133166  
 133167  AND assign(lhs, rhs, ff, op) BE
 133199  // Compile a simple assignment: lhs := rhs, lhs #:= rhs or lhs op := rhs.
 133273  // Note that for simultaneous assignments have already been replaced by
 133345  // sequences of simple assignments by cvassign.
 133393  
 133394  // If op=s_none the assigment is either lhs := rhs or lhs #:= rhs,
 133461  // otherwise it is of the form: lhs op:= rhs where op is one of
 133525  // the dyadic expression operators allowed in assignments, namely:
 133592  //    s_vecap,
 133607  //    s_mul,   s_div,  s_mod,  s_add,  s_sub,
 133653  //    s_fmul,  s_fdiv, s_fmod, s_fadd, s_fsub,
 133700  //    s_lshift, s_rshift, s_logand, s_logor, s_eqv or s_xor.
 133761  
 133762  // ff=TRUE if the rhs is to be evaluated in FLT mode.
 133816  
 133817  { LET sfop = op2sfop(op)
 133842    // sfop is either sf_none or
 133873    // an operator used in SELST Ocode instructions, namely:
 133932    //   sf_vecap,
 133949    //   sf_mul,  sf_div,  sf_mod,  sf_add,    sf_sub,
 134002    //   sf_fmul, sf_fdiv, sf_fmod, sf_fadd or sf_fsub.
 134056  
 134057    SWITCHON h1!lhs INTO
 134080    { CASE s_name:        // name op:= E
 134119        TEST op=s_none
 134140        THEN { // Compile: name := E
 134175               load(rhs, ff)
 134202               transname(lhs, s_sp, s_sg, s_sl, 0, 0)
 134254               ssp := ssp - 1
 134282             }
 134295        ELSE { // Compile: name sfop:= E
 134334               TEST noselst
 134360               THEN { // Load: lhs op rhs
 134400                      // op is a dyadic operator
 134447                      LET operator, a, b = op, lhs, rhs
 134501                      load(@operator, ff)
 134541                      transname(lhs, s_sp, s_sg, s_sl, 0, 0)
 134600                      ssp := ssp - 1
 134635                    }
 134655               ELSE { load(rhs, ff)
 134689                      loadlv(lhs)
 134721                      out4(s_selst, sfop, 0, 0)
 134767                      ssp := ssp - 2
 134802                    }
 134822             }
 134835        RETURN
 134848   
 134850      CASE s_rv:
 134865      CASE s_vecap:  IF op=s_none DO
 134900                     { load(rhs, ff)
 134935                       loadlv(lhs)
 134968                       out1(s_stind)
 135003                       ssp := ssp - 2
 135039                       RETURN
 135067                     }
 135088  
 135089                     // op is a dyadic expression operator allowed
 135154                     // in assignments.
 135192                     IF noselst DO
 135225                     { // Load: lhs op rhs
 135266                       // op is a dyadic operator
 135314                       LET operator, a, b = op, lhs, rhs
 135369                       // Load the expression whose tree node is [op,lhs,rhs]
 135445                       load(@operator, ff)
 135486                       loadlv(lhs)
 135519                       out1(s_stind)
 135554                       ssp := ssp - 2
 135590                       RETURN
 135618                     }
 135639  
 135640                     // Compile using SELST
 135682                     load(rhs, ff)
 135715                     loadlv(lhs)
 135746                     out4(s_selst, sfop, 0, 0) 
 135792                     ssp := ssp - 2
 135826                     RETURN
 135852  
 135853      CASE s_of:   { LET slct = evalconst(h2!lhs, FALSE) // Inserted 11/7/01
 135928                     LET len = slct>>24
 135966                     LET sh  = slct>>16 & 255
 136010                     LET offset = slct & #xFFFF
 136056                     LET mask = -1
 136089                     IF len>0 DO mask := (1<<len)-1
 136139                     mask := mask<<sh
 136175                     TEST noselst
 136207                     THEN { TEST op=s_none
 136248                            THEN { load(rhs, ff)
 136295                                 }
 136328                            ELSE { // Load: lhs op rhs
 136381                                   // op is a dyadic operator
 136441                                   LET operator, a, b = op, lhs, rhs
 136508                                   load(@operator, ff)
 136561                                 }
 136594                            IF sh DO
 136629                            { out2(s_ln, sh)
 136672                              out1(s_lshift)
 136715                            }
 136743  
 136744                            UNLESS mask=-1 DO
 136788                            { load(h3!lhs, FALSE)
 136836                              IF offset DO
 136877                              { out2(s_ln, offset)
 136926                                out1(s_add)
 136968                              }
 136998                              out1(s_rv)
 137037                              out1(s_xor)
 137077                              ssp := ssp-1
 137118                              out2(s_ln, mask)
 137163                              out1(s_logand) // bits to change in x
 137229                              load(h3!lhs, FALSE)
 137277                              IF offset DO
 137318                              { out2(s_ln, offset)
 137367                                out1(s_add)
 137409                              }
 137439                              out1(s_rv)
 137478                              out1(s_xor)
 137518                              ssp := ssp-1
 137559                            }
 137587  
 137588                            load(h3!lhs, FALSE)
 137634                            IF offset DO
 137673                            { out2(s_ln, offset)
 137720                              out1(s_add)
 137760                            }
 137788                            out1(s_stind)
 137828                          }
 137854                     ELSE { // Compile using SELST
 137903                            load(rhs, ff)
 137943                            load(h3!lhs, FALSE)
 137989                            IF offset DO
 138028                            { out2(s_ln, offset)
 138075                              out1(s_add)
 138115                            }
 138143                            TEST len=0 & sh=0 & sfop=sf_none
 138202                            THEN out1(s_stind) // Full word field
 138266                                               // and no op.
 138325                            ELSE out4(s_selst, sfop, len, sh) 
 138386                          }
 138412                     ssp := ssp-2
 138444                     RETURN
 138470                   }
 138489  
 138490      CASE s_byteap:
 138509        TEST op=s_none
 138530        THEN { // Compiling: E1%E2 := E3
 138569               load(rhs, ff)
 138596             }
 138609        ELSE { // Compiling: E1%E2 op:= E3
 138650               // op is a dyadic expression operator allowed
 138709               // in assignments.
 138741               LET operator, a, b = op, lhs, rhs
 138788  
 138789               // The destination is not a full word field,
 138847               // so some operators are not permitted.
 138900               IF sfop=sf_fmul | sfop=sf_fdiv | sfop=sf_fmod |
 138961                  sfop=sf_fadd | sfop=sf_fsub | sfop=sf_vecap DO
 139024                 trnerr("Bad op in E%E op:= E")
 139070  
 139071               // Load an expression whose tree node is [op,lhs,rhs]
 139138               load(@operator, FALSE)
 139174             }
 139187        load(h2!lhs, FALSE)
 139213        load(h3!lhs, FALSE)
 139239        out1(s_putbyte)
 139261        ssp:=ssp-3
 139278        RETURN
 139291  
 139292      DEFAULT:
 139305        trnerr("Ltype expression needed")
 139345    }
 139349  }
 139351   
 139353   
 139355  AND transname(x, p, g, l, f, n) BE
 139390  { // x is a name node
 139412    LET c = cellwithname(x)
 139438    LET k, a = h2!c, h3!c
 139462   
 139464    // Must deal with s_fglobal, s_flocal, s_f_static, s_flabel, s_fmanifest
 139539    // as if they were the integer versions. The sole purpose of these
 139608    // is to indicate than a name has been declared with the FLT tag.
 139676    // Note that s_fglobal = s_global  + s_fltbit,
 139725    // and       s_global  = s_fglobal & s_fltmask, etc
 139779    // where s_fltbit is 128 s_fltmask is 127.
 139824  
 139825    SWITCHON k INTO
 139843    { DEFAULT:        trnerr("Name '%s' not declared", @h3!x)
 139903     
 139907      CASE s_fglobal:
 139927      CASE s_global:  out2(g, a)
 139958                      IF xrefing DO
 139992                        xref(x,
 140022                             ((k & s_fltbit)=0 -> "G:", "FG:"),
 140084                             a, g)
 140117                      RETURN
 140144   
 140146      CASE s_flocal:
 140165      CASE s_local:   IF c<dvecp DO
 140199                           trnerr("Dynamic free variable '%s' used", @h3!x)
 140273                      out2(p, a)
 140304                      //IF xrefing DO
 140340                      //  xref(x,
 140372                      //       ((k & s_fltbit)=0 -> "P:", "FP:"),
 140436                      //       a, p)
 140471                      RETURN
 140498   
 140500      CASE s_fstatic:
 140520      CASE s_static:  out2(l, a)
 140551                      IF xrefing DO
 140585                        xref(x,
 140615                             ((k & s_fltbit)=0 -> "S:", "FS:"),
 140677                             a, l)
 140710                      RETURN
 140737   
 140739      CASE s_label:   IF f=0 DO
 140769                      { trnerr("Misuse of entry name '%s'", @h3!x)
 140834                        f := p
 140863                      }
 140885                      out2(f, a)
 140916                      IF xrefing DO xref(x, "F:", a, f)
 140970                      RETURN
 140997  
 140998      CASE s_fmanifest:
 141020      CASE s_manifest:IF n=0 DO
 141050                      { trnerr("Misuse of MANIFEST name '%s'", @h3!x)
 141118                        n := p
 141147                      }
 141169                      out2(n, a)
 141200                      IF xrefing DO
 141234                        xref(x,
 141264                             ((k & s_fltbit)=0 -> "M:", "FM:"),
 141326                             a, n)
 141359    }
 141363  }
 141365  
 141366  AND xref(x, kstr, n, op) BE
 141394  { // Output a line of cross reference info
 141437    // x is the name node
 141461    // kstr, n describe how the name is being used
 141510    // op decribes the context
 141539    LET name = @h3!x
 141558    LET fno = comline>>20
 141582    LET lno = comline & #xFFFFF
 141612    LET file = sourcenamev!fno
 141641    writef("%s %s", name, kstr)
 141671    TEST -10_000_000 <= n <= 10_000_000
 141709    THEN writef("%n ", n)
 141733    ELSE writef("#x%8x ", n)
 141760  
 141761    SWITCHON op INTO
 141780    { DEFAULT:         writef("op%n", op); ENDCASE
 141829  
 141830      CASE s_fndef:    writef("FN");       ENDCASE
 141879      CASE s_rtdef:    writef("RT");       ENDCASE
 141928      CASE s_local:    writef("LOC");      ENDCASE
 141977      CASE s_valdef:   writef("VAL");      ENDCASE
 142026      CASE s_vecdef:   writef("VEC");      ENDCASE
 142075      CASE s_constdef: writef("DEF");      ENDCASE
 142124      CASE s_const:    writef("MAN");      ENDCASE
 142173      CASE s_colon:    writef("LAB");      ENDCASE
 142222      CASE s_sp:       writef("SP");       ENDCASE
 142271      CASE s_sg:       writef("SG");       ENDCASE
 142320      CASE s_sl:       writef("SL");       ENDCASE
 142369      CASE s_llp:      writef("LLP");      ENDCASE
 142418      CASE s_llg:      writef("LLG");      ENDCASE
 142467      CASE s_lll:      writef("LLL");      ENDCASE
 142516      CASE s_lp:       writef("LP");       ENDCASE
 142565      CASE s_lg:       writef("LG");       ENDCASE
 142614      CASE s_ll:       writef("LL");       ENDCASE
 142663      CASE s_lf:       writef("LF");       ENDCASE
 142712      CASE s_ln:       writef("LN");       ENDCASE
 142761    }
 142765    wrch(' ')
 142777    IF file DO writef("%s", file)
 142809    writef("[%n] ", lno)
 142832  
 142833    prctxt(context)
 142851  
 142852    newline()
 142864  }
 142866  
 142867  AND prctxt(x) BE IF x DO 
 142893  { LET op, str = h1!x, ""
 142918  
 142919    SWITCHON op INTO
 142938    { DEFAULT:  prctxte(x, 7, 0); RETURN
 142977  
 142978      CASE s_fndef:
 142996           writef("LET ")
 143020           prctxte(h2!x, 7, 0)
 143049           wrch('(')
 143068           prctxte(h3!x, 7, 0)
 143097           writef(")=..")
 143121           RETURN
 143137  
 143138      CASE s_rtdef:
 143156           writef("LET ")
 143180           prctxte(h2!x, 7, 0)
 143209           wrch('(')
 143228           prctxte(h3!x, 7, 0)
 143257           writef(")BE..")
 143282           RETURN
 143298  
 143299      CASE s_valdef:
 143318           writef("LET ")
 143342           prctxte(h2!x, 6, 0)
 143371           writef("=")
 143392           prctxte(h3!x, 6, 0)
 143421           RETURN
 143437  
 143438      CASE s_vecdef:
 143457           writef("LET ")
 143481           prctxte(h2!x, 6, 0)
 143510           writef("=VEC ")
 143535           prctxte(h3!x, 6, 0)
 143564           RETURN
 143580  
 143581      CASE s_constdef:
 143602           prctxte(h3!x, 6, 0)
 143631           writef("=")
 143652           prctxte(h4!x, 6, 0)
 143681           RETURN
 143697  
 143698      CASE s_let:
 143714           writef("LET ")
 143738           prctxtd(h2!x, 6)
 143764           writef("; ")
 143786           prctxtc(h3!x, 6)
 143812           RETURN
 143828   
 143830      CASE s_static:    writef("STATIC..");    RETURN
 143882      CASE s_global:    writef("GLOBAL..");    RETURN
 143934      CASE s_manifest:  writef("MANIFEST..");  RETURN
 143986  
 143987  
 143988      CASE s_assvecap:  str := "!";    GOTO case_ass
 144039      CASE s_assfmul:   str := "#**";  GOTO case_ass
 144090      CASE s_assfdiv:   str := "#/";   GOTO case_ass
 144141      CASE s_assfmod:   str := "#MOD"; GOTO case_ass
 144192      CASE s_assfadd:   str := "#+";   GOTO case_ass
 144243      CASE s_assfsub:   str := "#-";   GOTO case_ass
 144294      CASE s_assmul:    str := "**";   GOTO case_ass
 144345      CASE s_assdiv:    str := "/";    GOTO case_ass
 144396      CASE s_assmod:    str := "MOD";  GOTO case_ass
 144447      CASE s_assadd:    str := "+";    GOTO case_ass
 144498      CASE s_asssub:    str := "-";    GOTO case_ass
 144549      CASE s_asslshift: str := "<<";   GOTO case_ass
 144600      CASE s_assrshift: str := ">>";   GOTO case_ass
 144651      CASE s_asslogand: str := "&";    GOTO case_ass
 144702      CASE s_asslogor:  str := "|";    GOTO case_ass
 144753      CASE s_asseqv:    str := "EQV";  GOTO case_ass
 144804      CASE s_assxor:    str := "XOR";  GOTO case_ass
 144855  
 144856      CASE s_fass:      str := "#";    GOTO case_ass
 144907  
 144908      CASE s_ass:       str := ""
 144940  case_ass:
 144950           prctxte(h2!x, 4, 0)
 144979           writef("%s:=", str)
 145008           prctxte(h3!x, 4, 0)
 145037           RETURN
 145053   
 145055      CASE s_rtap:
 145072           prctxte(h2!x, 6, 12)
 145102           writef("(")
 145123           prctxte(h3!x, 6, 0)
 145152           writef(")")
 145173           RETURN
 145189   
 145191      CASE s_goto:
 145208           writef("GOTO ")
 145233           prctxte(h2!x, 6, 0)
 145262           RETURN
 145278   
 145280      CASE s_colon:
 145298           prctxte(h2!x, 6, 0)
 145327           writef(":")
 145348           prctxt(h3!x, 6)
 145373           RETURN
 145389   
 145391      CASE s_unless:
 145410      CASE s_if:
 145425      CASE s_while:
 145443      CASE s_until:
 145461           writef(op=s_unless->"UNLESS ",
 145501                  op=s_if->"IF ",
 145533                  op=s_until->"UNTIL ",
 145571                  "WHILE "
 145596                 )
 145613           prctxte(h2!x, 6, 0)
 145642           writef(" DO ")
 145666           prctxtc(h3!x, 6)
 145692           RETURN
 145708  
 145709   
 145711      CASE s_test:
 145728           writef("TEST ")
 145753           prctxte(h2!x, 6, 0)
 145782           writef(" THEN ")
 145808           prctxtc(h3!x, 6)
 145834           writef(" ELSE ")
 145860           prctxtc(h4!x, 6)
 145886           RETURN
 145902   
 145904      CASE s_loop:
 145921           writef("LOOP")
 145945           RETURN
 145961   
 145963      CASE s_skip:
 145980           writef("{}")
 146002           RETURN
 146018   
 146020      CASE s_break:
 146038           writef("BREAK")
 146063           RETURN
 146079   
 146081      CASE s_return:
 146100           writef("RETURN")
 146126           RETURN
 146142   
 146144      CASE s_finish:
 146163           writef("FINISH")
 146189           RETURN
 146205   
 146207      CASE s_resultis:
 146228           writef("RESULTIS ")
 146257           prctxte(h2!x, 6, 0)
 146286           RETURN
 146302   
 146304      CASE s_repeatwhile:
 146328      CASE s_repeatuntil:
 146352           prctxtc(h2!x, 6)
 146378           writef(op=s_repeatwhile -> " REPEATWHILE ", " REPEATUNTIL ")
 146448           prctxte(h3!x, 6, 0)
 146477           RETURN
 146493   
 146495      CASE s_repeat:
 146514           prctxtc(h2!x, 6)
 146540           writef(" REPEAT")
 146567           RETURN
 146583   
 146585      CASE s_case:
 146602           writef("CASE ")
 146627           prctxte(h2!x, 6, 0)
 146656           writef(":.. ")
 146680           RETURN
 146696   
 146698      CASE s_default:
 146718           writef("DEFAULT:..")
 146748           RETURN
 146764   
 146766      CASE s_endcase:
 146786           writef("ENDCASE")
 146813           RETURN
 146829   
 146831      CASE s_switchon:
 146852           writef("SWITCHON ")
 146881           prctxte(h2!x, 6, 0)
 146910           writef(" INTO..")
 146937           RETURN
 146953   
 146955      CASE s_for:
 146971           writef("FOR ")
 146995           prctxte(h2!x, 6, 0)
 147024           writef("=")
 147045           prctxte(h3!x, 6, 0)
 147074           writef(" TO ")
 147098           prctxte(h4!x, 6, 0)
 147127           IF h5!x DO { writef(" BY "); prctxte(h5!x, 6, 0) }
 147187           writef(" DO..")
 147212           RETURN
 147228   
 147230      CASE s_seq:
 147246           prctxtc(h2!x, 6)
 147272           writef(";")
 147293           prctxtc(h3!x, 6)
 147319           RETURN
 147335    }
 147339  }
 147341  
 147342  AND prctxtd(x, d) BE writef("..")
 147376  AND prctxtc(x, d) BE writef("..")
 147410  
 147411  AND wrhexval(n) BE
 147430  { LET lsdig = n & #xFF
 147453    n := n>>8
 147465    IF n DO wrhexval(n)
 147487    writef("%2x", lsdig)
 147510  }
 147512  
 147513  AND prctxte(x, d, prec) BE IF x DO
 147548  { LET op = h1!x
 147564  
 147565    SWITCHON op INTO
 147584    { DEFAULT: ENDCASE
 147605  
 147606      CASE s_number: 
 147626                   { LET n = h2!x
 147658                     TEST -1_000_000<=n<=1_000_000
 147707                     THEN writef("%n", n)
 147747                     ELSE { IF n<0 DO
 147783                            { wrch('-')
 147807                              n := -n
 147822                            }
 147829                            writef("#x")
 147854                            wrhexval(n)
 147871                          }
 147876                     RETURN
 147902                   } 
 147922      
 147927      CASE s_fnum: 
 147945                   { LET n = h2!x
 147977                     writef("%5.3f", n)
 148015                     RETURN
 148041                   } 
 148061      
 148066      CASE s_flt :   writef("FLT %s", @h3!(h2!x)); RETURN
 148122      CASE s_name:   writef("%s", @h3!x);          RETURN
 148178      CASE s_true:   writef("TRUE");               RETURN
 148234      CASE s_false:  writef("FALSE");              RETURN
 148290      CASE s_query:  wrch('?');                    RETURN
 148346  
 148347      CASE s_string: 
 148367                   { LET s = @h2!x
 148400                     LET len = s%0
 148433                     wrch('"')
 148462                     FOR i = 1 TO len DO
 148501                     { LET ch = s%i
 148535                       IF i=6 & len>6+8 DO { writef("'"); LOOP }
 148598                       IF i<=6 | i>len-8 DO // First 5 and last 8 chars
 148668                       { SWITCHON ch INTO
 148708                         { CASE '**': writef("****"); LOOP
 148765                           CASE '*"': writef("***""); LOOP
 148822                           CASE '*n': writef("**n");  LOOP
 148879                         }
 148904                         UNLESS 32<=ch<=127 DO ch := '?'
 148959                         wrch(ch)
 148991                       }
 149014                     }
 149035                     wrch('"')
 149064                     RETURN
 149090                   }
 149109  
 149110    }
 149114  
 149115    IF d=0 DO { writef("..."); RETURN }
 149153  
 149154    IF prec>=12 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 149222  
 149223    SWITCHON op INTO
 149242    { DEFAULT: ENDCASE
 149263  
 149264      CASE s_fnap:
 149281           prctxte(h2!x, d-1, 11)
 149313           wrch('(')
 149332           prctxte(h3!x, d-1, 0)
 149363           wrch(')')
 149382           RETURN
 149398    }
 149402  
 149403    IF prec>=11 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 149471  
 149472    SWITCHON op INTO
 149491    { DEFAULT: ENDCASE
 149512  
 149513      CASE s_slct:
 149530        {  writes("SLCT ")
 149555           prctxte(h2!x, d-1, 10)
 149587           writes(":")
 149608           prctxte(h3!x, d-1, 10)
 149640           writes(":")
 149661           prctxte(h4!x, d-1, 10)
 149693           RETURN
 149709        }
 149717  
 149718      CASE s_of:
 149733      CASE s_byteap:
 149752      CASE s_vecap:
 149770           prctxte(h2!x, d-1, 10)
 149802           writes(op=s_of->"::", op=s_byteap->"%", "!")
 149856           prctxte(h3!x, d-1, 10)
 149888           RETURN
 149904  
 149905      CASE s_float:
 149923      CASE s_fix:
 149939      CASE s_rv:
 149954      CASE s_lv:
 149969           writef(op=s_float->"FLOAT ",
 150007                  op=s_fix  ->"FIX ",
 150043                  op=s_rv   ->"!",
 150076                              "@")
 150109           prctxte(h2!x, d-1, 10)
 150141           RETURN
 150157    }
 150161  
 150162    IF prec>=10 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 150230  
 150231    SWITCHON op INTO
 150250    { DEFAULT: ENDCASE
 150271      CASE s_mul: CASE s_div: CASE s_mod:
 150311           prctxte(h2!x, d-1, 9)
 150342           writef(op=s_mul->"**", op=s_div->"/", " MOD ")
 150398           prctxte(h3!x, d-1, 9)
 150429           RETURN
 150445  
 150446      CASE s_fmul: CASE s_fdiv: CASE s_fmod:
 150489           prctxte(h2!x, d-1, 9)
 150520           writef(op=s_fmul -> "#**",
 150556                  op=s_fdiv -> "#/",
 150591                               "#MOD ")
 150629           prctxte(h3!x, d-1, 9)
 150660           RETURN
 150676    }
 150680  
 150681    IF prec>=9 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 150748  
 150749    SWITCHON op INTO
 150768    { DEFAULT: ENDCASE
 150789      CASE s_add:
 150805      CASE s_sub:
 150821           prctxte(h2!x, d-1, 8)
 150852           writef(op=s_add->"+","-")
 150887           prctxte(h3!x, d-1, 8)
 150918           RETURN
 150934  
 150935      CASE s_fadd:
 150952      CASE s_fsub:
 150969           prctxte(h2!x, d-1, 8)
 151000           writef(op=s_fadd->"#+","#-")
 151038           prctxte(h3!x, d-1, 8)
 151069           RETURN
 151085  
 151086      CASE s_neg:
 151102      CASE s_fneg:
 151119      CASE s_fabs:
 151136      CASE s_abs:
 151152           writef(op=s_neg ->"-",
 151184                  op=s_fneg->"#-",
 151217                  op=s_fabs->"#ABS ",
 151253                             "ABS ")
 151288           prctxte(h2!x, d-1, 8)
 151319           RETURN
 151335    }
 151339  
 151340    IF prec>=8 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 151407  
 151408    SWITCHON op INTO
 151427    { DEFAULT: ENDCASE
 151448      CASE s_eq: CASE s_ne:
 151474           prctxte(h2!x, d-1, 7)
 151505           writef(op=s_eq->"=","~=")
 151540           prctxte(h3!x, d-1, 7)
 151571           RETURN
 151587  
 151588      CASE s_feq: CASE s_fne:
 151616           prctxte(h2!x, d-1, 7)
 151647           writef(op=s_feq->"#=","#~=")
 151685           prctxte(h3!x, d-1, 7)
 151716           RETURN
 151732  
 151733      CASE s_ls: CASE s_gr:
 151759           prctxte(h2!x, d-1, 7)
 151790           writef(op=s_ls->"<",">")
 151824           prctxte(h3!x, d-1, 7)
 151855           RETURN
 151871  
 151872      CASE s_fls: CASE s_fgr:
 151900           prctxte(h2!x, d-1, 7)
 151931           writef(op=s_fls->"#<","#>")
 151968           prctxte(h3!x, d-1, 7)
 151999           RETURN
 152015  
 152016      CASE s_le: CASE s_ge:
 152042           prctxte(h2!x, d-1, 7)
 152073           writef(op=s_le->"<=",">=")
 152109           prctxte(h3!x, d-1, 7)
 152140           RETURN
 152156  
 152157      CASE s_fle: CASE s_fge:
 152185           prctxte(h2!x, d-1, 7)
 152216           writef(op=s_fle->"#<=","#>=")
 152255           prctxte(h3!x, d-1, 7)
 152286           RETURN
 152302    }
 152306  
 152307    IF prec>=7 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 152374  
 152375    SWITCHON op INTO
 152394    { DEFAULT: ENDCASE
 152415      CASE s_lshift: CASE s_rshift:
 152449           prctxte(h2!x, d-1, 6)
 152480           writef(op=s_lshift->"<<",">>")
 152520           prctxte(h3!x, d-1, 6)
 152551           RETURN
 152567    }
 152571  
 152572    IF prec>=6 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 152639  
 152640    SWITCHON op INTO
 152659    { DEFAULT: ENDCASE
 152680      CASE s_not:
 152696           wrch('~')
 152715           prctxte(h2!x, d-1, 5)
 152746           RETURN
 152762    }
 152766  
 152767    IF prec>=5 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 152834  
 152835    SWITCHON op INTO
 152854    { DEFAULT: ENDCASE
 152875      CASE s_logand:
 152894           prctxte(h2!x, d-1, 4)
 152925           wrch('&')
 152944           prctxte(h3!x, d-1, 4)
 152975           RETURN
 152991    }
 152995  
 152996    IF prec>=4 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 153063  
 153064    SWITCHON op INTO
 153083    { DEFAULT: ENDCASE
 153104      CASE s_logor:
 153122           prctxte(h2!x, d-1, 3)
 153153           wrch('|')
 153172           prctxte(h3!x, d-1, 3)
 153203           RETURN
 153219    }
 153223  
 153224    IF prec>=3 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 153291  
 153292    SWITCHON op INTO
 153311    { DEFAULT: ENDCASE
 153332      CASE s_eqv:
 153348      CASE s_xor:
 153364           prctxte(h2!x, d-1, 2)
 153395           writef(op=s_eqv->" EQV "," XOR ")
 153438           prctxte(h3!x, d-1, 2)
 153469           RETURN
 153485  
 153486    }
 153490  
 153491    IF prec>=2 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 153558  
 153559    SWITCHON op INTO
 153578    { DEFAULT: ENDCASE
 153599  
 153600      CASE s_cond:
 153617      CASE s_fcond:
 153635           prctxte(h2!x, d-1, 1)
 153666           writef(op=s_cond -> "->", "#->")
 153708           prctxte(h3!x, d-1, 1)
 153739           writef(",")
 153760           prctxte(h4!x, d-1, 1)
 153791           RETURN
 153807    }
 153811  
 153812    IF prec>=1 DO { wrch('('); prctxte(x, d, 0); wrch(')'); RETURN }
 153879  
 153880    SWITCHON op INTO
 153899    { DEFAULT: writef("Op%n", op); RETURN
 153939  
 153940      CASE s_table:
 153958           writef("TABLE ")
 153984           prctxte(h2!x, d-1, 0)
 154015           RETURN
 154031           
 154041      CASE s_valof:
 154059           writef("VALOF{")
 154085           prctxtc(h2!x, d-1)
 154113           wrch('}')
 154132           RETURN
 154148  
 154149      CASE s_comma:
 154167           prctxte(h2!x, d-1, 0)
 154198           writef(",")
 154219           prctxte(h3!x, d-1, 0)
 154250           RETURN
 154266    }
 154270  }
 154272  
 154273  
 154274  AND out1(x) BE wrn(x)
 154296   
 154298  AND out2(x, y) BE { out1(x); out1(y) }
 154337   
 154339  AND out3(x, y, z) BE { out1(x); out1(y); out1(z) }
 154390   
 154392  AND out4(x, y, z, t) BE { out1(x); out1(y); out1(z); out1(t) }
 154455   
 154457  AND outstring(s) BE FOR i = 0 TO s%0 DO out1(s%i)
 154507  
